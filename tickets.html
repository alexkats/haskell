<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>tickets</title>
<!-- 2017-03-27 пн 03:09 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Алексей Кацман" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">tickets</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. <span class="todo TODO">TODO</span> <code>[9/16]</code> Билеты</a>
<ul>
<li><a href="#sec-1-1">1.1. <span class="done DONE">DONE</span> <code>[5/5]</code> Lecture 1: Why FP and Haskell</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1. <span class="done DONE">DONE</span> Плюсы функциональной чистоты</a></li>
<li><a href="#sec-1-1-2">1.1.2. <span class="done DONE">DONE</span> Плюсы неизменяемости (иммутабельности)</a></li>
<li><a href="#sec-1-1-3">1.1.3. <span class="done DONE">DONE</span> Плюсы ленивости</a></li>
<li><a href="#sec-1-1-4">1.1.4. <span class="done DONE">DONE</span> Преимущества статической типизации</a></li>
<li><a href="#sec-1-1-5">1.1.5. <span class="done DONE">DONE</span> Удачные конструкции языка Haskell</a></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2. <span class="done DONE">DONE</span> <code>[17/17]</code> Lecture 2: Basic syntax</a>
<ul>
<li><a href="#sec-1-2-1">1.2.1. <span class="done DONE">DONE</span> Отступы важны и все такое прочее!!!</a></li>
<li><a href="#sec-1-2-2">1.2.2. <span class="done DONE">DONE</span> Разница между statement и expression</a></li>
<li><a href="#sec-1-2-3">1.2.3. <span class="done DONE">DONE</span> Функции - обычные и параметрические</a></li>
<li><a href="#sec-1-2-4">1.2.4. <span class="done DONE">DONE</span> Списки и функции на списках</a></li>
<li><a href="#sec-1-2-5">1.2.5. <span class="done DONE">DONE</span> Лямбды (анонимные функции)</a></li>
<li><a href="#sec-1-2-6">1.2.6. <span class="done DONE">DONE</span> Let expression</a></li>
<li><a href="#sec-1-2-7">1.2.7. <span class="done DONE">DONE</span> Where clause</a></li>
<li><a href="#sec-1-2-8">1.2.8. <span class="done DONE">DONE</span> If expression</a></li>
<li><a href="#sec-1-2-9">1.2.9. <span class="done DONE">DONE</span> Guards</a></li>
<li><a href="#sec-1-2-10">1.2.10. <span class="done DONE">DONE</span> Case expression</a></li>
<li><a href="#sec-1-2-11">1.2.11. <span class="done DONE">DONE</span> Функции высшего порядка</a></li>
<li><a href="#sec-1-2-12">1.2.12. <span class="done DONE">DONE</span> Частичное применение</a></li>
<li><a href="#sec-1-2-13">1.2.13. <span class="done DONE">DONE</span> Что-то про flip</a></li>
<li><a href="#sec-1-2-14">1.2.14. <span class="done DONE">DONE</span> Pattern matching</a></li>
<li><a href="#sec-1-2-15">1.2.15. <span class="done DONE">DONE</span> Композиция функций и применение</a></li>
<li><a href="#sec-1-2-16">1.2.16. <span class="done DONE">DONE</span> Ranges</a></li>
<li><a href="#sec-1-2-17">1.2.17. <span class="done DONE">DONE</span> List comprehension</a></li>
</ul>
</li>
<li><a href="#sec-1-3">1.3. <span class="done DONE">DONE</span> <code>[10/10]</code> Lecture 3: Datas, Classes, Instances</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1. <span class="done DONE">DONE</span> Типы и классы типов</a></li>
<li><a href="#sec-1-3-2">1.3.2. <span class="done DONE">DONE</span> Type aliases</a></li>
<li><a href="#sec-1-3-3">1.3.3. <span class="done DONE">DONE</span> Объявление своего типа данных (Algebraic Data Types)</a></li>
<li><a href="#sec-1-3-4">1.3.4. <span class="done DONE">DONE</span> Record syntax</a></li>
<li><a href="#sec-1-3-5">1.3.5. <span class="done DONE">DONE</span> Классы типов (Type classes)</a></li>
<li><a href="#sec-1-3-6">1.3.6. <span class="done DONE">DONE</span> Deriving</a></li>
<li><a href="#sec-1-3-7">1.3.7. <span class="done DONE">DONE</span> Super classes</a></li>
<li><a href="#sec-1-3-8">1.3.8. <span class="done DONE">DONE</span> Type classes as Dictionaries</a></li>
<li><a href="#sec-1-3-9">1.3.9. <span class="done DONE">DONE</span> Datatype Contexts</a></li>
<li><a href="#sec-1-3-10">1.3.10. <span class="done DONE">DONE</span> Modules cheatsheet</a></li>
</ul>
</li>
<li><a href="#sec-1-4">1.4. <span class="done DONE">DONE</span> <code>[8/8]</code> Lecture 4: Kinda Monoids</a>
<ul>
<li><a href="#sec-1-4-1">1.4.1. <span class="done DONE">DONE</span> Newtype</a></li>
<li><a href="#sec-1-4-2">1.4.2. <span class="done DONE">DONE</span> Фантомные типы</a></li>
<li><a href="#sec-1-4-3">1.4.3. <span class="done DONE">DONE</span> Kinds</a></li>
<li><a href="#sec-1-4-4">1.4.4. <span class="done DONE">DONE</span> Higher kinded classes</a></li>
<li><a href="#sec-1-4-5">1.4.5. <span class="done DONE">DONE</span> Foldr and foldl</a></li>
<li><a href="#sec-1-4-6">1.4.6. <span class="done DONE">DONE</span> Monoid</a></li>
<li><a href="#sec-1-4-7">1.4.7. <span class="done DONE">DONE</span> Foldable type class</a></li>
<li><a href="#sec-1-4-8">1.4.8. <span class="done DONE">DONE</span> <code>[8/8]</code> Language extensions</a></li>
</ul>
</li>
<li><a href="#sec-1-5">1.5. <span class="done DONE">DONE</span> <code>[8/8]</code> Lecture 5: Monads, part 1</a>
<ul>
<li><a href="#sec-1-5-1">1.5.1. <span class="done DONE">DONE</span> Монада и ее законы</a></li>
<li><a href="#sec-1-5-2">1.5.2. <span class="done DONE">DONE</span> Maybe monad</a></li>
<li><a href="#sec-1-5-3">1.5.3. <span class="done DONE">DONE</span> Identity monad</a></li>
<li><a href="#sec-1-5-4">1.5.4. <span class="done DONE">DONE</span> Either monad</a></li>
<li><a href="#sec-1-5-5">1.5.5. <span class="done DONE">DONE</span> Monad composition</a></li>
<li><a href="#sec-1-5-6">1.5.6. <span class="done DONE">DONE</span> List monad</a></li>
<li><a href="#sec-1-5-7">1.5.7. <span class="done DONE">DONE</span> Join</a></li>
<li><a href="#sec-1-5-8">1.5.8. <span class="done DONE">DONE</span> Полезные функции для монад</a></li>
</ul>
</li>
<li><a href="#sec-1-6">1.6. <span class="done DONE">DONE</span> <code>[10/10]</code> Lecture 6: Functors, Applicative Functors</a>
<ul>
<li><a href="#sec-1-6-1">1.6.1. <span class="done DONE">DONE</span> Functor</a></li>
<li><a href="#sec-1-6-2">1.6.2. <span class="done DONE">DONE</span> Bifunctor</a></li>
<li><a href="#sec-1-6-3">1.6.3. <span class="done DONE">DONE</span> Applicative</a></li>
<li><a href="#sec-1-6-4">1.6.4. <span class="done DONE">DONE</span> liftAN и стиль программирования с аппликативами</a></li>
<li><a href="#sec-1-6-5">1.6.5. <span class="done DONE">DONE</span> Alternative</a></li>
<li><a href="#sec-1-6-6">1.6.6. <span class="done DONE">DONE</span> List comprehension sugar</a></li>
<li><a href="#sec-1-6-7">1.6.7. <span class="done DONE">DONE</span> Traversable type class</a></li>
<li><a href="#sec-1-6-8">1.6.8. <span class="done DONE">DONE</span> Automatic deriving (Functor, Foldable, Traversable)</a></li>
<li><a href="#sec-1-6-9">1.6.9. <span class="done DONE">DONE</span> <code>[4/4]</code> Type hierarchy proposals</a></li>
<li><a href="#sec-1-6-10">1.6.10. <span class="done DONE">DONE</span> Type classes hierarchy</a></li>
</ul>
</li>
<li><a href="#sec-1-7">1.7. <span class="done DONE">DONE</span> <code>[7/7]</code> Lecture 7: Monads, part 2</a>
<ul>
<li><a href="#sec-1-7-1">1.7.1. <span class="done DONE">DONE</span> Writer monad</a></li>
<li><a href="#sec-1-7-2">1.7.2. <span class="done DONE">DONE</span> Reader monad</a></li>
<li><a href="#sec-1-7-3">1.7.3. <span class="done DONE">DONE</span> Typed holes</a></li>
<li><a href="#sec-1-7-4">1.7.4. <span class="done DONE">DONE</span> Partial type signatures</a></li>
<li><a href="#sec-1-7-5">1.7.5. <span class="done DONE">DONE</span> State monad</a></li>
<li><a href="#sec-1-7-6">1.7.6. <span class="done DONE">DONE</span> RWS monad</a></li>
<li><a href="#sec-1-7-7">1.7.7. <span class="done DONE">DONE</span> Cont monad and Continuation Passing Style (CPS)</a></li>
</ul>
</li>
<li><a href="#sec-1-8">1.8. <span class="done DONE">DONE</span> <code>[8/8]</code> Lecture 8: RealWorld</a>
<ul>
<li><a href="#sec-1-8-1">1.8.1. <span class="done DONE">DONE</span> Building IO system from scratch</a></li>
<li><a href="#sec-1-8-2">1.8.2. <span class="done DONE">DONE</span> Introduce IO Monad</a></li>
<li><a href="#sec-1-8-3">1.8.3. <span class="done DONE">DONE</span> <code>[3/3]</code> do notation</a></li>
<li><a href="#sec-1-8-4">1.8.4. <span class="done DONE">DONE</span> Mutable data: IORef and IOArray</a></li>
<li><a href="#sec-1-8-5">1.8.5. <span class="done DONE">DONE</span> sequence_</a></li>
<li><a href="#sec-1-8-6">1.8.6. <span class="done DONE">DONE</span> Exceptions (catch, throwIO, custom exceptions, bracket, etc.)</a></li>
<li><a href="#sec-1-8-7">1.8.7. <span class="done DONE">DONE</span> unsafePerformIO and unsafeInterleaveIO</a></li>
<li><a href="#sec-1-8-8">1.8.8. <span class="done DONE">DONE</span> Efficient String representations: Text, ByteString</a></li>
</ul>
</li>
<li><a href="#sec-1-9">1.9. <span class="done DONE">DONE</span> <code>[7/7]</code> Lecture 9: Monad Transformers</a>
<ul>
<li><a href="#sec-1-9-1">1.9.1. <span class="done DONE">DONE</span> Композиция монад</a></li>
<li><a href="#sec-1-9-2">1.9.2. <span class="done DONE">DONE</span> Пример с MaybeIO</a></li>
<li><a href="#sec-1-9-3">1.9.3. <span class="done DONE">DONE</span> MaybeT transformer</a></li>
<li><a href="#sec-1-9-4">1.9.4. <span class="done DONE">DONE</span> ReaderT transformer</a></li>
<li><a href="#sec-1-9-5">1.9.5. <span class="done DONE">DONE</span> StateT transformer</a></li>
<li><a href="#sec-1-9-6">1.9.6. <span class="done DONE">DONE</span> Таблица трансформеров</a></li>
<li><a href="#sec-1-9-7">1.9.7. <span class="done DONE">DONE</span> Mtl style of transformation</a></li>
</ul>
</li>
<li><a href="#sec-1-10">1.10. <span class="todo TODO">TODO</span> <code>[0/12]</code> Lecture 10: Speeding up haskell</a>
<ul>
<li><a href="#sec-1-10-1">1.10.1. <span class="todo TODO">TODO</span> List concatenation pitfalls and Difference List</a></li>
<li><a href="#sec-1-10-2">1.10.2. <span class="todo TODO">TODO</span> foldr vs foldl vs foldl'_</a></li>
<li><a href="#sec-1-10-3">1.10.3. <span class="todo TODO">TODO</span> WHNF (weak head normal form)</a></li>
<li><a href="#sec-1-10-4">1.10.4. <span class="todo TODO">TODO</span> seq, deepseq, NFData</a></li>
<li><a href="#sec-1-10-5">1.10.5. <span class="todo TODO">TODO</span> Irrefutable patterns</a></li>
<li><a href="#sec-1-10-6">1.10.6. <span class="todo TODO">TODO</span> BangPatterns</a></li>
<li><a href="#sec-1-10-7">1.10.7. <span class="todo TODO">TODO</span> Strict Haskell</a></li>
<li><a href="#sec-1-10-8">1.10.8. <span class="todo TODO">TODO</span> Space leaks</a></li>
<li><a href="#sec-1-10-9">1.10.9. <span class="todo TODO">TODO</span> Deforestation</a></li>
<li><a href="#sec-1-10-10">1.10.10. <span class="todo TODO">TODO</span> Streal Fusion</a></li>
<li><a href="#sec-1-10-11">1.10.11. <span class="todo TODO">TODO</span> ST monad (STRef, STArray)</a></li>
<li><a href="#sec-1-10-12">1.10.12. <span class="todo TODO">TODO</span> Criterion</a></li>
</ul>
</li>
<li><a href="#sec-1-11">1.11. <span class="todo TODO">TODO</span> <code>[0/3]</code> Lecture 11: Template Haskell and Lens</a>
<ul>
<li><a href="#sec-1-11-1">1.11.1. <span class="todo TODO">TODO</span> <code>[0/2]</code> Template Haskell</a></li>
<li><a href="#sec-1-11-2">1.11.2. <span class="todo TODO">TODO</span> <code>[0/3]</code> Lens</a></li>
<li><a href="#sec-1-11-3">1.11.3. <span class="todo TODO">TODO</span> Prism</a></li>
</ul>
</li>
<li><a href="#sec-1-12">1.12. <span class="todo TODO">TODO</span> <code>[0/9]</code> Lecture 12: Parallel and Concurrent Haskell</a>
<ul>
<li><a href="#sec-1-12-1">1.12.1. <span class="todo TODO">TODO</span> Advantages of immutability and purity</a></li>
<li><a href="#sec-1-12-2">1.12.2. <span class="todo TODO">TODO</span> Haskell parallelism with rpar and rseq</a></li>
<li><a href="#sec-1-12-3">1.12.3. <span class="todo TODO">TODO</span> Threadscope</a></li>
<li><a href="#sec-1-12-4">1.12.4. <span class="todo TODO">TODO</span> Strategies</a></li>
<li><a href="#sec-1-12-5">1.12.5. <span class="todo TODO">TODO</span> Par monad examples</a></li>
<li><a href="#sec-1-12-6">1.12.6. <span class="todo TODO">TODO</span> Difference between Parallelism and Concurrency</a></li>
<li><a href="#sec-1-12-7">1.12.7. <span class="todo TODO">TODO</span> forkIO and MVar</a></li>
<li><a href="#sec-1-12-8">1.12.8. <span class="todo TODO">TODO</span> Transactions: STM, TVar</a></li>
<li><a href="#sec-1-12-9">1.12.9. <span class="todo TODO">TODO</span> Async</a></li>
</ul>
</li>
<li><a href="#sec-1-13">1.13. <span class="todo TODO">TODO</span> <code>[0/5]</code> Lecture 13: Comonads</a>
<ul>
<li><a href="#sec-1-13-1">1.13.1. <span class="todo TODO">TODO</span> Comonad type class &amp; motivation (Identity comonad)</a></li>
<li><a href="#sec-1-13-2">1.13.2. <span class="todo TODO">TODO</span> <code>[0/4]</code> Zippers</a></li>
<li><a href="#sec-1-13-3">1.13.3. <span class="todo TODO">TODO</span> <code>[0/4]</code> Comonads</a></li>
<li><a href="#sec-1-13-4">1.13.4. <span class="todo TODO">TODO</span> codo-notation (aka method)</a></li>
<li><a href="#sec-1-13-5">1.13.5. <span class="todo TODO">TODO</span> Comonad transformers</a></li>
</ul>
</li>
<li><a href="#sec-1-14">1.14. <span class="todo TODO">TODO</span> <code>[3/6]</code> Lecture 14: Enterprise Haskell</a>
<ul>
<li><a href="#sec-1-14-1">1.14.1. <span class="done DONE">DONE</span> <code>[3/3]</code> Build tools</a></li>
<li><a href="#sec-1-14-2">1.14.2. <span class="done DONE">DONE</span> Testing: HSpec, QuickCheck</a></li>
<li><a href="#sec-1-14-3">1.14.3. <span class="done DONE">DONE</span> FFI</a></li>
<li><a href="#sec-1-14-4">1.14.4. <span class="todo TODO">TODO</span> <code>[0/2]</code> Databases</a></li>
<li><a href="#sec-1-14-5">1.14.5. <span class="todo TODO">TODO</span> Network.HTTP</a></li>
<li><a href="#sec-1-14-6">1.14.6. <span class="todo TODO">TODO</span> Web.Scotty</a></li>
</ul>
</li>
<li><a href="#sec-1-15">1.15. <span class="todo TODO">TODO</span> <code>[0/7]</code> Lecture 15: Advanced type features</a>
<ul>
<li><a href="#sec-1-15-1">1.15.1. <span class="todo TODO">TODO</span> <code>[0/4]</code> forall keyword</a></li>
<li><a href="#sec-1-15-2">1.15.2. <span class="todo TODO">TODO</span> <code>[0/4]</code> Examples for all</a></li>
<li><a href="#sec-1-15-3">1.15.3. <span class="todo TODO">TODO</span> <code>[0/2]</code> GADTs</a></li>
<li><a href="#sec-1-15-4">1.15.4. <span class="todo TODO">TODO</span> <code>[0/4]</code> -XDataKinds</a></li>
<li><a href="#sec-1-15-5">1.15.5. <span class="todo TODO">TODO</span> Extensible records</a></li>
<li><a href="#sec-1-15-6">1.15.6. <span class="todo TODO">TODO</span> -XTypeApplications</a></li>
<li><a href="#sec-1-15-7">1.15.7. <span class="todo TODO">TODO</span> -XTypeOperators</a></li>
</ul>
</li>
<li><a href="#sec-1-16">1.16. <span class="todo TODO">TODO</span> <code>[0/0]</code> Lecture 16: Idris</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> <span class="todo TODO">TODO</span> <code>[9/16]</code> Билеты</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> <span class="done DONE">DONE</span> <code>[5/5]</code> Lecture 1: Why FP and Haskell</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> <span class="done DONE">DONE</span> Плюсы функциональной чистоты</h4>
<div class="outline-text-4" id="text-1-1-1">
<ul class="org-ul">
<li>БОльшие возможности для оптимизации
</li>
<li>Чисто функциональные программы легче понимать и отлаживать, так как результат функции зависит только от входных значений – отлаживать функцию можно независимо от остальной программы, при этом ее всегда можно разбить на меньшие подфункции и отладить их отдельно.
</li>
<li>Чистые функции намного проще объединять в композиции, так как между ними нет неявных связей в виде изменяемого состояния.
</li>
<li>Чисто функциональные программы проще сделать параллельными. Чистая функция всегда является <code>thread-safe</code>, т.е. ее можно вызывать из нескольких потоков одновременно.
</li>
<li>Чистые функции не изменяют глобального состояния программы и системы в целом.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> <span class="done DONE">DONE</span> Плюсы неизменяемости (иммутабельности)</h4>
<div class="outline-text-4" id="text-1-1-2">
<ul class="org-ul">
<li>После создания объекта, методы не изменяют существующие, а возвращают новый объект.
</li>
<li>Если объекты неизменяемые, наличие нескольких ссылок на один объект не создает проблем, такие ссылки можно без опасений передавать и хранить в структурах данных.
</li>
<li>Поведение неизменяемых объектов очень простое, так как их состояние не меняется. Понимать программы с их использованием намного проще.
</li>
<li>Неизменяемые объекты не зависят от истории, так как объекты никак не меняются при вызове их методов.
</li>
<li>Нет проблем с хранением объектов в коллекциях, т.к., например, значение хэш-функции в хэш-таблице для неизменяемого объекта не изменится, а значит мы не потеряем его.
</li>
<li>Нет изменяемых объектов - нет проблем с многопоточным доступом.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3"><span class="section-number-4">1.1.3</span> <span class="done DONE">DONE</span> Плюсы ленивости</h4>
<div class="outline-text-4" id="text-1-1-3">
<ul class="org-ul">
<li>Можно присваивать значения в любом порядке, т.к. при ленивых  вычислениях вычисление значения произойдет только при его  использовании.
</li>
<li>Программа работает более эффективно, так как вычисления происходят только в тех случаях, когда это действительно нужно.
</li>
<li>Можно использовать бесконечные структуры данных (бесконечные списки, бесконечные деревья). Можно манипулировать ими так же, как и обычными – главное, чтобы никогда не вычислялся весь список целиком.
</li>
<li>Можно использовать все это добро в pattern matching, по списку хотя бы, он опять же не будет вычисляться целиком, например, удобно взять только голову списка, не вычисляя его целиком.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4"><span class="section-number-4">1.1.4</span> <span class="done DONE">DONE</span> Преимущества статической типизации</h4>
<div class="outline-text-4" id="text-1-1-4">
<ul class="org-ul">
<li>Раннее обнаружение ошибок – на этапе компиляции, а не выполнения. На удивление часто программа на SML или Haskell работает правильно сразу, как только ее наконец удается скомпилировать.
</li>
<li>Поддерживаемость больших проектов при статической типизации намного выше, так как изменения могут быть верифицированы компилятором, и типы являются частью документации программы, облегчающие ее понимание.
</li>
<li>Для статически типизированных языков проще делать автоматизированную обработку программ (автоматический рефакторинг, как в средах IDEA или Eclipse).
</li>
<li>Для статически типизированных языков проще оптимизация кода, так что в среднем они эффективнее динамически типизированных.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-5" class="outline-4">
<h4 id="sec-1-1-5"><span class="section-number-4">1.1.5</span> <span class="done DONE">DONE</span> Удачные конструкции языка Haskell</h4>
<div class="outline-text-4" id="text-1-1-5">
<ul class="org-ul">
<li>Замыкания (closures) – их трудно полноценно реализовать в языке без сборки мусора типа C++ (upward funarg problem)
</li>
<li>Каррирование (currying) – то же, что для замыканий плюс проблемы с перегрузкой функций по числу аргументов, как принято во многих императивных языках
</li>
<li>Вывод типов (type inference) – глобальный вывод типов накладывает серьезные ограничения на систему типов; так, наличие наследования резко ослабляет возможности вывода типов
</li>
<li>Сопоставление с образцом (pattern matching)
</li>
<li>Классы типов (type classes)
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> <span class="done DONE">DONE</span> <code>[17/17]</code> Lecture 2: Basic syntax</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> <span class="done DONE">DONE</span> Отступы важны и все такое прочее!!!</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
Ну просто отступы реально играют роль :)
</p>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> <span class="done DONE">DONE</span> Разница между statement и expression</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
Существуют понятия statement (хз про человеческий перевод, наверное, что-то типо оператора (это значит - инструкция)) и expression (выражение). В императивных языках есть и то, и другое. В хаскеле все является выражениями (ну или почти все). Короче, разницу умею объяснять только маханием руками с примерами, написать не могу.
</p>
</div>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> <span class="done DONE">DONE</span> Функции - обычные и параметрические</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
Функции бывают обычными и параметрическими. Сказать что-то про то, как объявляются, вызываются и т.п. (совсем базовые вещи).
</p>

<p>
Полиморфизм - бывает двух типов - параметрический и <code>ad-hoc</code>. Второе (частный случай) - перегрузка методов (в духе <code>int length(String s)</code>
и <code>int length(Locale l, String s)</code> в <code>Java</code>). В хаскеле же параметрический полиморфизм. По сути это просто параметрические типы в функциях (а-ля generics в java).
<code>Ad-hoc</code> полиморфизм в хаскеле тоже есть - это на самом деле классы типов.
</p>
</div>
</div>
<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4"><span class="section-number-4">1.2.4</span> <span class="done DONE">DONE</span> Списки и функции на списках</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
Списки - классная вещь, используются везде. Важно сказать про образование списка.
В духе <code>[1,2,3]</code> есть синтаксический сахар и на самом деле происходит такое <code>1:2:3:[]</code>.
Еще важно, что строка - список символов, поэтому <code>“” == []</code>.
</p>

<p>
Функции на списках:
</p>
<ul class="org-ul">
<li>head
</li>
</ul>
<p>
<code>head :: [a] &rarr; a</code>
<code>head [1,2,3] == 1</code>
</p>
<ul class="org-ul">
<li>tail
</li>
</ul>
<p>
<code>tail :: [a] &rarr; [a]</code>
<code>tail [1,2,3] == [2,3]</code>
</p>
<ul class="org-ul">
<li>init
</li>
</ul>
<p>
<code>init :: [a] &rarr; [a]</code>
<code>init [1,2,3] == [1,2]</code>
</p>
<ul class="org-ul">
<li>last
</li>
</ul>
<p>
<code>last :: [a] &rarr; a</code>
<code>last [1,2,3] == 3</code>
</p>
<ul class="org-ul">
<li>drop
</li>
</ul>
<p>
<code>drop 2 [1,2,3] == [3]</code> (отбрасывает первые <code>n</code> элементов)
</p>
<ul class="org-ul">
<li>take
</li>
</ul>
<p>
<code>take 1 [1,2,3] == [1]</code> (берет первые <code>n</code> элементов)
</p>
<ul class="org-ul">
<li>replicate
</li>
</ul>
<p>
<code>replicate 3 [1,2,3] == [[1,2,3],[1,2,3],[1,2,3]]</code> (кидает в новый список данный <code>n</code> раз)
</p>
<ul class="org-ul">
<li>zip
</li>
</ul>
<p>
<code>zip [1,2,3] “abc” == [(1, ‘a’), (2, ‘b’), (3, ‘c’)]</code> (берет 2 списка, образует пары по элементам списков и кидает в новый список, обрезает по короткому списку)
</p>
<ul class="org-ul">
<li>unzip
</li>
</ul>
<p>
<code>unzip [(5, True), (10, False)] == ([5,10], [True,False])</code> (обратное к <code>zip</code>, возвращает пару из двух списков)
</p>
<ul class="org-ul">
<li>zipWith
</li>
</ul>
<p>
<code>zipWith max [10,5,1] [2,1,3] == [10,5,3]</code> (берет каждый раз по элементу из каждого списка и применяет переданную функцию, кидает значение в новый список, обрезает по короткому списку опять же)
</p>
<ul class="org-ul">
<li>Есть еще всякие <code>takeWhile</code>, <code>dropWhile</code>, <code>splitAt</code> (все берут предикат и как-то делят на 2 списка или 1), <code>iterate</code>, <code>reverse</code> and so on.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-5" class="outline-4">
<h4 id="sec-1-2-5"><span class="section-number-4">1.2.5</span> <span class="done DONE">DONE</span> Лямбды (анонимные функции)</h4>
<div class="outline-text-4" id="text-1-2-5">
<p>
Лямбды - анонимные функции. Синтаксис на примере лучше:
</p>
<div class="org-src-container">

<pre class="src src-haskell">l = [2,1,3]
squares = map (\x &rarr; x * x) l
lambdaMulAdd = \x y z &rarr; x * y + z
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-6" class="outline-4">
<h4 id="sec-1-2-6"><span class="section-number-4">1.2.6</span> <span class="done DONE">DONE</span> Let expression</h4>
<div class="outline-text-4" id="text-1-2-6">
<div class="org-src-container">

<pre class="src src-haskell">z :: Int
z = let l = [2,1,3]
        h = head l
    in h + 10
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-7" class="outline-4">
<h4 id="sec-1-2-7"><span class="section-number-4">1.2.7</span> <span class="done DONE">DONE</span> Where clause</h4>
<div class="outline-text-4" id="text-1-2-7">
<div class="org-src-container">

<pre class="src src-haskell">pythagoras :: Double &rarr; Double &rarr; Double
pythagoras a b = a2 + b2
  where
    square x = x ^ 2
    a2       = square a
    b2       = square b
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-8" class="outline-4">
<h4 id="sec-1-2-8"><span class="section-number-4">1.2.8</span> <span class="done DONE">DONE</span> If expression</h4>
<div class="outline-text-4" id="text-1-2-8">
<div class="org-src-container">

<pre class="src src-haskell">f :: Integer &rarr; Integer
f n = if n &lt;= 1 then 1 else n * f (n - 1)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-9" class="outline-4">
<h4 id="sec-1-2-9"><span class="section-number-4">1.2.9</span> <span class="done DONE">DONE</span> Guards</h4>
<div class="outline-text-4" id="text-1-2-9">
<div class="org-src-container">

<pre class="src src-haskell">collatzSum :: Integer &rarr; Integer
collatzSum n
    | n &lt; 0     = n
    | n == 1    = 1
    | even n    = n + collatzSum (n `div` 2)
    | otherwise = n + collatzSum (3 * n + 1)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-10" class="outline-4">
<h4 id="sec-1-2-10"><span class="section-number-4">1.2.10</span> <span class="done DONE">DONE</span> Case expression</h4>
<div class="outline-text-4" id="text-1-2-10">
<div class="org-src-container">

<pre class="src src-haskell">getFont :: Int &rarr; String
getFont n = case n of
    0 &rarr; "PLAIN"
    1 &rarr; "BOLD"
    2 &rarr; "ITALIC"
    _ &rarr; "UNKNOWN"
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-11" class="outline-4">
<h4 id="sec-1-2-11"><span class="section-number-4">1.2.11</span> <span class="done DONE">DONE</span> Функции высшего порядка</h4>
<div class="outline-text-4" id="text-1-2-11">
<p>
HOF (higher-order functions - функции высшего порядка) - по сути
функции, которые в качестве аргументов могут принимать другие
функции:
</p>

<ul class="org-ul">
<li>apply
</li>
</ul>
<p>
<code>apply :: Int &rarr; Int &rarr; (Int &rarr; Int &rarr; Int) &rarr; Int</code>
<code>apply a b f = f a b</code>
<code>x = apply 3 4 (\x y &rarr; x + y)</code>
<code>y = apply 3 4 (+)</code>
</p>
<ul class="org-ul">
<li>map
</li>
</ul>
<p>
<code>map :: (a &rarr; b) &rarr; [a] &rarr; [b]</code>
<code>map negate [2,1,3] == [-2,-1,-3]</code>
</p>
<ul class="org-ul">
<li>filter
</li>
</ul>
<p>
<code>filter :: (a &rarr; Bool) &rarr; [a] &rarr; [a]</code>
<code>filter odd [1,2,3,4,5] == [1,3,5]</code>
</p>
<ul class="org-ul">
<li>foldr1
</li>
</ul>
<p>
<code>foldr1 :: (a &rarr; a &rarr; a) &rarr; [a] &rarr; a</code>
<code>foldr1 (+) [1,2,4] == 7</code>
</p>
<ul class="org-ul">
<li>span
</li>
</ul>
<p>
<code>span :: (a &rarr; Bool) &rarr; [a] &rarr; ([a], [a])</code>
<code>span even [2,4,5,2,7] == ([2,4],[5,2,7])</code>
</p>
<ul class="org-ul">
<li>partition
</li>
</ul>
<p>
<code>partition even [2,4,5,2,7] == ([2,4,2],[5,7])</code>
</p>
<ul class="org-ul">
<li>takeWhile
</li>
</ul>
<p>
<code>takeWhile isUpper”HTMLXml” == ”HTMLX”</code>
</p>
<ul class="org-ul">
<li>uncurry
</li>
</ul>
<p>
<code>uncurry :: (a &rarr; b &rarr; c) &rarr; (a, b) &rarr; c</code>
<code>uncurry f (x, y) = f x y</code>
<code>uncurry (+) (3,4) == 7</code>
</p>
<ul class="org-ul">
<li>curry
</li>
</ul>
<p>
<code>curry :: ((a, b) &rarr; c) &rarr; a &rarr; b &rarr; c</code>
<code>curry f a b = f (a, b)</code>
<code>curry fst 3 4 == 3</code>
<code>curry snd 3 4 == 4</code>
</p>
</div>
</div>
<div id="outline-container-sec-1-2-12" class="outline-4">
<h4 id="sec-1-2-12"><span class="section-number-4">1.2.12</span> <span class="done DONE">DONE</span> Частичное применение</h4>
<div class="outline-text-4" id="text-1-2-12">
<p>
Сказать что-то в духе, что мы можем применять функции частично и
это классно. Например, такая штука:
</p>
<div class="org-src-container">

<pre class="src src-haskell">map :: (a &rarr; b) &rarr; [a] &rarr; [b]
add5 :: [Int] &rarr; [Int]
add5 = map (+5)
</pre>
</div>
<p>
А потом просто делаем <code>add5 [1,2,3]</code> и получаем <code>[6,7,8]</code>, и
удобно, не надо делать <code>map (+5) [1,2,3]</code>, особенно если нам надо
постоянно прибавлять 5 к куче списков. Искусственный пример,
конечно, но за идею сойдет.
</p>
</div>
</div>
<div id="outline-container-sec-1-2-13" class="outline-4">
<h4 id="sec-1-2-13"><span class="section-number-4">1.2.13</span> <span class="done DONE">DONE</span> Что-то про flip</h4>
<div class="outline-text-4" id="text-1-2-13">
<div class="org-src-container">

<pre class="src src-haskell">flip :: (a &rarr; b &rarr; c) &rarr; b &rarr; a &rarr; c
flip f b a = f a b
show2 :: Int &rarr; Int &rarr; String
show2 x y = show x ++ " and " ++ show y
showSnd, showFst, showFst' :: Int &rarr; String
showSnd = show2 1
showFst = flip show2 2
showFrs' = (`show2` 2)
id :: a &rarr; a
flip id :: b &rarr; (b &rarr; c) &rarr; c
($) :: (a &rarr; b) &rarr; a &rarr; b
flip ($) :: a &rarr; (a &rarr; c) &rarr; c
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-14" class="outline-4">
<h4 id="sec-1-2-14"><span class="section-number-4">1.2.14</span> <span class="done DONE">DONE</span> Pattern matching</h4>
<div class="outline-text-4" id="text-1-2-14">
<p>
Можно помахать руками и выдумать любой пример, нет смысла писать.
</p>
</div>
</div>
<div id="outline-container-sec-1-2-15" class="outline-4">
<h4 id="sec-1-2-15"><span class="section-number-4">1.2.15</span> <span class="done DONE">DONE</span> Композиция функций и применение</h4>
<div class="outline-text-4" id="text-1-2-15">
<div class="org-src-container">

<pre class="src src-haskell">infixr 9 . -- правая ассоциативность, 9 приоритет (max), оператор (.)
(.) :: (b &rarr; c) &rarr; (a &rarr; b) &rarr; a &rarr; c
f . g = \x &rarr; f (g x)

infixl 0 $ -- левая ассоциативность, 0 приоритет (min) оператор ($)
($) :: (a &rarr; b) &rarr; a &rarr; b
f $ x = f x

incNegate x = negate (x + 1)
incNegate x = negate $ x + 1
incNegate x = (negate . (+1)) x
incNegate x = negate . (+1) $ x
incNegate = negate . (+1) -- &eta;-редукция

stringsTransform :: [String] &rarr; [String]
stringsTransform l = map (\s &rarr; map toUpper s) (filter (\s &rarr; length s == 5) l)
stringsTransform l = map (\s &rarr; map toUpper s) $ filter (\s &rarr; length s == 5) l
stringsTransform l = map (map toUpper) $ filter ((==5) . length) l
stringsTransform = map (map toUpper) . filter ((==5) . length)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-16" class="outline-4">
<h4 id="sec-1-2-16"><span class="section-number-4">1.2.16</span> <span class="done DONE">DONE</span> Ranges</h4>
<div class="outline-text-4" id="text-1-2-16">
<div class="org-src-container">

<pre class="src src-haskell">[0..5] == [0,1,2,3,4,5]
[0, 2..5] == [0,2,4]
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-17" class="outline-4">
<h4 id="sec-1-2-17"><span class="section-number-4">1.2.17</span> <span class="done DONE">DONE</span> List comprehension</h4>
<div class="outline-text-4" id="text-1-2-17">
<div class="org-src-container">

<pre class="src src-haskell">[x | x &larr; [1..10], even x] == [2,4,6,8,10]
filter even [1..10] == [2,4,6,8,10]
[if even x then "!" else "?" | x &larr; [1..5]] == ["?","!","?","!","?"]
[x * y | x &larr; [1,3,5], y &larr; [2,4,6], x * y &gt;= 10] == [12,18,10,20,30]

primes :: [Int]
primes = filterPrime [2..]
  where
    filterPrime (p:xs) = p : filterPrime [x | x &larr; xs, x `mod` p /= 0]
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> <span class="done DONE">DONE</span> <code>[10/10]</code> Lecture 3: Datas, Classes, Instances</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> <span class="done DONE">DONE</span> Типы и классы типов</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
<code>:t</code> - показывает тип того, что идет за ней
<code>::</code> - дословно "имеет тип"
<code>:t fst == fst :: (a, b) &rarr; a</code>
</p>

<p>
Класс типов - интерфейс, определяющий некоторое поведение.
Классы типов:
</p>
<ol class="org-ol">
<li><code>Eq</code> - класс, имеющий проверку на равенство
</li>
<li><code>Ord</code> - класс, предназначенный для типов, поддерживающих отношение порядка
</li>
<li><code>Show</code> - типы этого класса могу быть представлены как строки
</li>
<li><code>Read</code> - обратное к <code>Show</code>, читает строку и преобразует в значение, тип которого является экземпляром класса <code>Read</code>
</li>
<li><code>Enum</code> - последовательно упорядоченные типы, значения можно пронумеровать
</li>
<li><code>Bounded</code> - имеет верхнюю и нижнюю границы
</li>
<li><code>Num</code> - числа
</li>
<li><code>Floating</code> - числа с плавающей точкой
</li>
<li><code>Integral</code> - целые числа
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> <span class="done DONE">DONE</span> Type aliases</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Представление одного типа разными способами:
</p>
<div class="org-src-container">

<pre class="src src-haskell">type String = [Char]
type BinaryIntFunction = Int &rarr; Int &rarr; Int
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> <span class="done DONE">DONE</span> Объявление своего типа данных (Algebraic Data Types)</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
В общем, может быть такая штука как сумма типов: ST = T<sub>1</sub> + &#x2026; + T<sub>n</sub> (по сути <code>enum</code> - перечисления, но это, скорее, частный случай).
Бывает произведение типов: PT = T<sub>1</sub> &times; &#x2026; &times; T<sub>n</sub> (частный случай - структуры в плюсах).
В хаскеле есть ADT (алгебраические типы данных):
</p>
<div class="org-src-container">

<pre class="src src-haskell">T ::= Int | Double | Char | ...
ADT ::= T | ADT + ADT | ADT &times; ADT

data Color = Red | Green | Blue

data User = User Int String String
getUid :: User &rarr; Int
getUid (User uid _ _) = uid

data Vector a = Vector2D a a | Vector3D a a a

data Maybe a = Nothing | Just a

data Either a b = Left a | Right b -- Возможная ошибка с результатом ошибки

data List = Nil | Cons a (List a)

data Shape = Circle Float Float Float | Rectangle Float Float Float Float
:t Circle == Float &rarr; Float &rarr; Float &rarr; Shape

data Person = Person { firstName :: String
                     , lastName :: String
                     , age :: Int
                     } deriving (Show)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3-4" class="outline-4">
<h4 id="sec-1-3-4"><span class="section-number-4">1.3.4</span> <span class="done DONE">DONE</span> Record syntax</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
Что-то такое:
</p>
<div class="org-src-container">

<pre class="src src-haskell">data User = User { uid :: Int
                 , login :: String
                 , password :: String
                 }
</pre>
</div>
<p>
Все эти поля - по сути геттеры (как в джаве). Не могут повторяться
имена (хотя в <code>GHC 8</code> что-то хитрое появилось. чтобы избегать
такого, но это не надо сейчас).
</p>
<div class="org-src-container">

<pre class="src src-haskell">isIvan :: User &rarr; Bool
isIvan User { login = "Ivan" } = True
isIvan _                       = False
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3-5" class="outline-4">
<h4 id="sec-1-3-5"><span class="section-number-4">1.3.5</span> <span class="done DONE">DONE</span> Классы типов (Type classes)</h4>
<div class="outline-text-4" id="text-1-3-5">
<div class="org-src-container">

<pre class="src src-haskell">class Eq a where
    (==) :: a &rarr; a &rarr; Bool
    (/=) :: a &rarr; a &rarr; Bool

    x == y = not (x /= y)
    x /= y = not (x == y)

    -- == | /= - minimal complete definition

class Printable p where
    printMe :: p &rarr; String

data Foo = Foo

instance Printable Foo where
    printMe Foo = "Foo"

helloP :: Printable p &rArr; p &rarr; String
helloP p = "Hello, " ++ printMe p ++ "!"

class I a where
    measure :: a &rarr; Int &rarr; Double

class J a where
    getParameter :: a &rarr; Int

doMeasure :: (I a, J a) &rArr; a &rarr; Double
doMeasure obj = measure obj $ getParameter obj
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3-6" class="outline-4">
<h4 id="sec-1-3-6"><span class="section-number-4">1.3.6</span> <span class="done DONE">DONE</span> Deriving</h4>
<div class="outline-text-4" id="text-1-3-6">
<p>
Короче, <code>deriving</code> может делаться только для определенных
классов типов по умолчанию. Собственно это <code>Eq</code>, <code>Ord</code>, <code>Bounded</code>,
<code>Show</code>, <code>Read</code> и <code>Enum</code>. При этом внутри <code>data</code> должны быть типы,
которые тоже инстансы этих классов типов.
</p>
</div>
</div>
<div id="outline-container-sec-1-3-7" class="outline-4">
<h4 id="sec-1-3-7"><span class="section-number-4">1.3.7</span> <span class="done DONE">DONE</span> Super classes</h4>
<div class="outline-text-4" id="text-1-3-7">
<div class="org-src-container">

<pre class="src src-haskell">data Ordering = LT | EQ | GT

class Eq a &rArr; Ord a where
    compare :: a &rarr; a &rarr; Ordering
    (&lt;), (&lt;=), (&gt;=), (&gt;) :: a &rarr; a &rarr; Bool

    compare x y
        | x == y    = EQ
        | x &lt;= y    = LT
        | otherwise = GT

    x &lt;= y = compare x y /= GT
    x &lt; y  = compare x y == LT
    x &gt;= y = compare x y /= LT
    x &gt; y  = compare x y == GT
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3-8" class="outline-4">
<h4 id="sec-1-3-8"><span class="section-number-4">1.3.8</span> <span class="done DONE">DONE</span> Type classes as Dictionaries</h4>
<div class="outline-text-4" id="text-1-3-8">
<div class="org-src-container">

<pre class="src src-haskell">data EqC a = EqDict { eq :: a &rarr; a &rarr; Bool
                    , neq :: a &rarr; a &rarr; Bool
                    }

instanceEqCWithEq :: (a &rarr; a &rarr; Bool) &rarr; EqC a
instanceEqCWithEq myEq = EqDict { eq = myEq
                                , neq = \x y &rarr; not $ x `myEq` y
                                }

instanceEqCWithNeq :: (a &rarr; a &rarr; Bool) &rarr; EqC a
instanceEqCWithNeq myNeq = EqDict { eq = \x y &rarr; not $ x `myNeq` y
                                  , neq = myNeq
                                  }

isInList :: EqC a &rarr; a &rarr; [a] &rarr; Bool
isInList eqc x = any (eq eqc x)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3-9" class="outline-4">
<h4 id="sec-1-3-9"><span class="section-number-4">1.3.9</span> <span class="done DONE">DONE</span> Datatype Contexts</h4>
<div class="outline-text-4" id="text-1-3-9">
<div class="org-src-container">

<pre class="src src-haskell">data (Ord a) &rArr; OrderedList a = Nil | Node { value :: a
                                          , next :: OrderedList a
                                          }
</pre>
</div>
<p>
Суть в том, что мы делаем ограничение на параметрический тип
внутри объявления нашего типа данных. Это очень фигово, ибо нам
не всегда требуется, чтобы наш тип данных имел ограничение,
например, нам необязательно знать, что вставляемый элемент в
список является инстансом <code>Ord</code>:
<code>insert :: a &rarr; OrderedList a &rarr; OrderedList a</code>
Так мы сделать не может, ибо нужно написать ограничение на <code>a</code>,
но оно здесь лишнее и абсолютно не нужно. Поэтому делать
ограничения на типы данных фигово и вообще никому не нужно и
вообще устарело (Deprecated).
</p>
</div>
</div>
<div id="outline-container-sec-1-3-10" class="outline-4">
<h4 id="sec-1-3-10"><span class="section-number-4">1.3.10</span> <span class="done DONE">DONE</span> Modules cheatsheet</h4>
<div class="outline-text-4" id="text-1-3-10">
<div class="org-src-container">

<pre class="src src-haskell">module Lib
    ( module Exports
    , FooB1 (..), FooB3 (FF)
    , Data.List.nub, C.isUpper
    , fooA, bazA, BAZB.isLower
    ) where -- тут просто указываем то, что хотим экспортировать

import           Foo.A
import           Foo.B (FooB2 (MkB1), FooB3 (..)) -- импортируем определенные штуки из модулей
import           Prelude hiding (print) -- импортируем все, кроме print
import           Bar.A (print, (&lt;||&gt;))
import           Bar.B ()

import           Baz.A as BAZA
import qualified Data.List
import qualified Data.Char as C hiding (chr)
import qualified Baz.B as BAZB (isLower) -- классный импорт, просто говорим, с каким именем хотим использовать импортированный модуль

import qualified Foo.X as Exports
import qualified Foo.Y as Exports
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> <span class="done DONE">DONE</span> <code>[8/8]</code> Lecture 4: Kinda Monoids</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> <span class="done DONE">DONE</span> Newtype</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
Тоже позволяет создавать типы данных, как и <code>data</code>.
Цель <code>newtype</code> - переименовать существующий тип, дав ему новый.
Можем делать pattern matching и создавать значение,
используя конструктор, как в <code>data</code>. На <code>newtype</code> есть некоторые
ограничения. Там должен быть один конструктор с ровно одним
полем. Но параметрических может быть сколько угодно. Примеры:
</p>
<div class="org-src-container">

<pre class="src src-haskell">newtype Param a b = Param (Either a b)
newtype Record = Record { getInt :: Int }
newtype Good = Good Int
</pre>
</div>
<p>
Одно из ключевых отличий: <code>data</code> нужно хранить какую-то
информацию о себе в runtime, например, данные о том, какой
конструктор был использован при создании. У <code>newtype</code> только
один конструктор, поэтому в runtime все это оптимизируется,
ибо нафиг не надо знать ничего о конструкторе, по сути он там
даже не существует. В частности, можно показать, что
pattern matching по-разному работает на <code>undefined</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">case D undefined of D _ &rarr; 1 -- OK, конструктор матчится, больше ничего не нужно
case undefined of D _ &rarr; 1 -- error, undefined считается, когда пытается счатчиться по конструктору и кидает ошибку
case N undefined of N _ &rarr; 1 -- ожидаемо OK
case undefined of N _ &rarr; 1 -- OK, потому что в рантайме нет конструктора, соответственно он просто матчится по значению, а оно может быть любым, поэтому undefined не считается и все классно
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> <span class="done DONE">DONE</span> Фантомные типы</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
Фантомный тип - параметризованный тип, у которого не все
параметры используются в правой части:
</p>
<div class="org-src-container">

<pre class="src src-haskell">newtype Coin color = Coin { getCoint :: Int }

data Blue
data Red

blue = undefined :: Blue
red = undefined :: Red

createCoins :: color &rarr; Int &rarr; Coin color
createCoins _ = Coin

c1 = createCoins blue 10
c2 = Coin 5 :: Coin Red

addCoins :: Coin color &rarr; Coin color &rarr; Coin color
addCoins (Coin a) (Coin b) = Coin (a + b)
</pre>
</div>
<p>
Нафиг надо? Суть в том. что это некая проверка. В последней
функции видно, что мы не можем сложить монеты разных цветов,
это довольно классное утверждение, нам не нужно хранить какой-то
цвет у монеты в значении, это просто будет вшито в параметрический
тип, что довольно удобно.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3"><span class="section-number-4">1.4.3</span> <span class="done DONE">DONE</span> Kinds</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
Kind - по сути тип типа
</p>
<div class="org-src-container">

<pre class="src src-haskell">Maybe :: * &rarr; *
Maybe String :: *
[] :: * &rarr; *
[] Int :: *
(&rarr;) :: * &rarr; * &rarr; *
(&rarr;) Int :: * &rarr; *
</pre>
</div>
<p>
Kind polymorphism:
</p>
<div class="org-src-container">

<pre class="src src-haskell">data Computable a f = Computation (f a) a
Computable :: * &rarr; (* &rarr; *) &rarr; *
Computable String :: (* &rarr; *) &rarr; *
Computable INt Maybe :: *

data IntComputation f = MkIntComp (f Int) -- 1 способ
type IntComputation f = Computable Int f -- 2 способ
IntComputation :: (* &rarr; *) &rarr; *

-- GHC 8 (-XTypeInType)
data PolyComputable (f :: k &rarr; *) (a :: k) = PolyComputation (f a)
PolyComputable :: (k &rarr; *) &rarr; k &rarr; *
PolyComputable Maybe :: * &rarr; *
PolyComputable IntComputation :: (* &rarr; *) &rarr; *

-- Constaint kind
type CustomC a = (Read a, Num a)
foo :: CustomC a &rArr; String &rarr; a &rarr; a
CustomC :: * &rarr; Constaint

type SDict p = p &rArr; Int
SDict :: Constraint &rarr; *
foo :: SDict (Ord a)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-4" class="outline-4">
<h4 id="sec-1-4-4"><span class="section-number-4">1.4.4</span> <span class="done DONE">DONE</span> Higher kinded classes</h4>
<div class="outline-text-4" id="text-1-4-4">
<p>
В общем идея в том, что штуки вроде <code>class Box b where ...</code>
называются higher kinded classes. Идея как и с higher
order functions, только для kind-ов. Тут у штуки <code>b</code>
kind <code>* &rarr; *</code>, и теперь становится понятно, какие
параметризованные типы можно подставлять вместо <code>b</code>. Например,
<code>Maybe</code> имеет kind <code>* &rarr; *</code>, значит можно сделать
<code>instance Box Maybe where ...</code>. Короче удобно чекать такие штуки
и смотреть, что не так в итоге, поэтому разбираться в kind-ах
классно.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-5" class="outline-4">
<h4 id="sec-1-4-5"><span class="section-number-4">1.4.5</span> <span class="done DONE">DONE</span> Foldr and foldl</h4>
<div class="outline-text-4" id="text-1-4-5">
<div class="org-src-container">

<pre class="src src-haskell">foldl :: Foldable t &rArr; (b &rarr; a &rarr; b) &rarr; b &rarr; t a &rarr; b
foldr :: Foldable t &rArr; (a &rarr; b &rarr; b) &rarr; b &rarr; t a &rarr; b

foldl _ acc []     = acc
foldl f acc (x:xs) = foldl (f acc x) xs

foldl (+) 0 [1,2,3] == (((0 + 1) + 2) + 3)

foldr _ acc []     = acc
foldr f acc (x:xs) = f x (foldr f acc xs)

foldr (+) 0 [1,2,3] == 1 + (2 + (3 + 0))
</pre>
</div>
<p>
Вроде итак понятно, не знаю, что добавить. Можно сказать, что
есть еще <code>foldr’</code> - не особо ленивая версия <code>foldl</code>. Просто
<code>foldl</code> хранит выражение целиком, пока оно не потребуется, в
итоге тратится дофига памяти. <code>foldl’</code> не строит огромную
цепочку исполнения, он пытается каждый раз выполнить функцию.
Суть в том, что там используется <code>seq</code>, который каждый раз
заставляет выражение вычислиться, на примере лучше видно:
</p>
<div class="org-src-container">

<pre class="src src-haskell">foldl' (+) 1 (2:3:[]) -- раскроется в:
let new = 1 + 2
new `seq` foldl' (+) new (3:[])
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-6" class="outline-4">
<h4 id="sec-1-4-6"><span class="section-number-4">1.4.6</span> <span class="done DONE">DONE</span> Monoid</h4>
<div class="outline-text-4" id="text-1-4-6">
<div class="org-src-container">

<pre class="src src-haskell">class Monoid m where
    mempty :: m
    mappend :: m &rarr; m &rarr; m

    mconcat :: [m] &rarr; m

infixr 6 &lt;&gt;
(&lt;&gt;) :: Monoid m &rArr; m &rarr; m &rarr; m
(&lt;&gt;) = mappend

newtype Sum a = Sum { getSum :: a }
newtype Product a = Product { getProduct :: a }

instance Num a &rArr; Monoid (Sum a) where
    mempty = Sum 0
    mappend x y = Sum (getSum x + getSum y)

instance Product a &rArr; Monoid (Product a) where
    mempty = Product 1
    mappend x y = Product (getProduct x * getProduct y)

instance Monoid [a] where
    mempty = []
    mappend xs ys = xs ++ ys

instance Monoid a &rArr; Monoid (Maybe a) where
    mempty = Nothing
    mappend Nothing m         = Nothing
    mappend m Nothing         = Nothing
    mappend (Just x) (Just y) = Just (mappend x y)

instance (Monoid a, Monoid b) &rArr; Monoid (a, b) where
    mempty = (mempty, mempty)
    mappend (a1, b1) (a2, b2) = (mappend a1 a2, mappend b1 b2)

instance Monoid b &rArr; Monoid (a &rarr; b) where
    mempty _ = mempty
    mappend f g x = f x `mappend` g x

instance Monoid Ordering where
    mempty = EQ
    mappend LT _ = LT
    mappend EQ y = y
    mappend GT _ = GT
</pre>
</div>
<p>
Finger Tree - какая-то хрень, нафиг никому не нужная и вообще
лажа, но вроде персистентное дерево (хранит историю изменений),
которое почему-то удобно использовать в ФП именно, наверное,
удобно реализовывать. А еще, судя по всему, можно из этого
запросто сделать инстанс моноида, но мне лень разбираться.
Иначе нафига это в теме про моноиды.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-7" class="outline-4">
<h4 id="sec-1-4-7"><span class="section-number-4">1.4.7</span> <span class="done DONE">DONE</span> Foldable type class</h4>
<div class="outline-text-4" id="text-1-4-7">
<div class="org-src-container">

<pre class="src src-haskell">class Foldable t where
    fold :: Monoid m &rArr; t m &rarr; m
    foldMap :: Monoid m &rArr; (a &rarr; m) &rarr; t a &rarr; m
    foldr :: (a &rarr; b &rarr; b) &rarr; b &rarr; t a &rarr; b

    foldMap f = foldr (mappend . f) mempty

    -- foldMap | foldr - minimal complete definition

instance Foldable [] where
    foldr = List.foldr

instance Foldable Maybe where
    foldr _ z Nothing  = z
    foldr f z (Just x) = f x z

instance Foldable (Either a) where
    foldMap _ (Left _)  = mempty
    foldMap f (Right y) = f y
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-8" class="outline-4">
<h4 id="sec-1-4-8"><span class="section-number-4">1.4.8</span> <span class="done DONE">DONE</span> <code>[8/8]</code> Language extensions</h4>
<div class="outline-text-4" id="text-1-4-8">
</div>
<ol class="org-ol"><li><a id="sec-1-4-8-1" name="sec-1-4-8-1"></a><span class="done DONE">DONE</span> TypeSynonymInstances<br  /><div class="outline-text-5" id="text-1-4-8-1">
<p>
Разрешает делать инстансы для синонимов типов (по стандарту нельзя):
</p>
<div class="org-src-container">

<pre class="src src-haskell">{-# LANGUAGE TypeSynonymInstances #-}

module MessageInstance where

data Message = Message String String Int String
type MSG = Message

instance Monoid MSG where
    ...
</pre>
</div>
</div>
</li>
<li><a id="sec-1-4-8-2" name="sec-1-4-8-2"></a><span class="done DONE">DONE</span> FlexibleInstances<br  /><div class="outline-text-5" id="text-1-4-8-2">
<p>
По умолчанию можно передавать только параметризованные типы в
инстанс, обходим с помощью этого расширения:
</p>
<div class="org-src-container">

<pre class="src src-haskell">data Tree a = Leaf | Node a (Tree a) (Tree a)

instance Ord (Tree Int) where
    ...
</pre>
</div>
</div>
</li>
<li><a id="sec-1-4-8-3" name="sec-1-4-8-3"></a><span class="done DONE">DONE</span> GeneralizedNewtypeInstances<br  /><div class="outline-text-5" id="text-1-4-8-3">
<p>
По умолчанию может у <code>newtype</code> сделать <code>deriving</code> только <code>Eq</code>,
<code>Ord</code>, <code>Enum</code> и <code>Bounded</code>. Расширение позволяет это обойти и
сделать так:
</p>
<div class="org-src-container">

<pre class="src src-haskell">newtype Size = Size Int deriving (Show, Read, Eq, Ord, Num)
</pre>
</div>
</div>
</li>
<li><a id="sec-1-4-8-4" name="sec-1-4-8-4"></a><span class="done DONE">DONE</span> MultiParamTypeClasses<br  /><div class="outline-text-5" id="text-1-4-8-4">
<p>
Изначально не можем сделать класс типов с несколькими параметрами, теперь можем:
</p>
<div class="org-src-container">

<pre class="src src-haskell">class Convertable a b where
    convert :: a &rarr; b

convertApply :: Convertable a b &rArr; (b &rarr; c) &rarr; a &rarr; c
convertApply f x = f $ convert x
</pre>
</div>
</div>
</li>
<li><a id="sec-1-4-8-5" name="sec-1-4-8-5"></a><span class="done DONE">DONE</span> DuplicateRecordFields<br  /><div class="outline-text-5" id="text-1-4-8-5">
<p>
Теперь можем использовать одинаковые названия полей у разных
<code>data</code> в record syntax:
</p>
<div class="org-src-container">

<pre class="src src-haskell">data Man = Man { name :: String } deriving (Show)
data Cat = Cat { name :: String } deriving (Show)

shoutOnHumanBeing :: Man &rarr; String
shoutOnHumanBeing man = (name :: Man &rarr; String) man ++ "!!1!"

isGrumpy :: Cat &rarr; Bool
isGrumpy Cat { name = "Grumpy" } = True
isGrumpy _                       = False
</pre>
</div>
</div>
</li>
<li><a id="sec-1-4-8-6" name="sec-1-4-8-6"></a><span class="done DONE">DONE</span> MultiWayIf<br  /><div class="outline-text-5" id="text-1-4-8-6">
<p>
Само за себя говорит - <code>guards</code> внутри <code>if</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">fn :: Int &rarr; Int &rarr; String
fn x y = if | x == 1    &rarr; "a"
            | y &lt;  2    &rarr; "b"
            | otherwise &rarr; "C"

main = putStrLn $ fn 3 4 -- should print "c"
</pre>
</div>
</div>
</li>
<li><a id="sec-1-4-8-7" name="sec-1-4-8-7"></a><span class="done DONE">DONE</span> ViewPatterns<br  /><div class="outline-text-5" id="text-1-4-8-7">
<p>
Прикольная штука, которая позволяет в pattern matching вызвать
некую функцию просмотра внутри паттерна:
</p>
<div class="org-src-container">

<pre class="src src-haskell">isZeroSum :: (Eq a, Num a) &rArr; [a] &rarr; Bool
isZeroSum (sum &rarr; 0) = True
isZeroSum _         = False
</pre>
</div>
</div>
</li>
<li><a id="sec-1-4-8-8" name="sec-1-4-8-8"></a><span class="done DONE">DONE</span> RecordWildCards<br  /><div class="outline-text-5" id="text-1-4-8-8">
<p>
Разрешает не писать кучу ненужного дерьма в record syntax:
</p>
<div class="org-src-container">

<pre class="src src-haskell">data User = User { uid :: Int
                 , login :: String
                 , password :: String
                 } deriving (Show)

toUnsafeString :: User &rarr; String
toUnsafeString User { uid = 0, .. } = "ROOT: " ++ login ++ ", " ++ password
toUnsafeString User {..}            = login ++ ":" ++ password
</pre>
</div>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> <span class="done DONE">DONE</span> <code>[8/8]</code> Lecture 5: Monads, part 1</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> <span class="done DONE">DONE</span> Монада и ее законы</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
Монада - контейнер для вычислений
</p>

<div class="org-src-container">

<pre class="src src-haskell">class Monad m a where
    return :: a &rarr; m a -- return
    (&gt;&gt;=) :: m a &rarr; (a &rarr; m b) &rarr; m b -- bind

    (&gt;&gt;) :: m a &rarr; m b &rarr; m b -- then
    m &gt;&gt; k = m &gt;&gt;= \_ &rarr; k

(=&lt;&lt;) :: Monad m &rArr; (a &rarr; m b) &rarr; m a &rarr; m b
f =&lt;&lt; x = x &gt;&gt;= f

infixl 1 &gt;&gt;, &gt;&gt;=
infixr 1 =&lt;&lt;
</pre>
</div>
<p>
Законы:
</p>
<ol class="org-ol">
<li><code>return a &gt;&gt;= f == f a</code> - left identity
</li>
<li><code>m &gt;&gt;= return == m</code> - right identity
</li>
<li><code>(m &gt;&gt;= f) &gt;&gt;= g == m &gt;&gt;= (\x &rarr; f x &gt;&gt;= g)</code> - associativity
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2"><span class="section-number-4">1.5.2</span> <span class="done DONE">DONE</span> Maybe monad</h4>
<div class="outline-text-4" id="text-1-5-2">
<div class="org-src-container">

<pre class="src src-haskell">data Maybe a = Just a | Nothing

instance Monad Maybe where
    return = Just
    Nothing &gt;&gt;= _ = Nothing
    Just x &gt;&gt;= f  = f x

Just 5 &gt;&gt;= (\x &rarr; Just $ x + 3) -- Just 8
Just 5 &gt;&gt;= (\x &rarr; return $ x + 3) -- Just 8
Nothing &gt;&gt;= (\x &rarr; return $ x + 3) -- Nothing
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3"><span class="section-number-4">1.5.3</span> <span class="done DONE">DONE</span> Identity monad</h4>
<div class="outline-text-4" id="text-1-5-3">
<div class="org-src-container">

<pre class="src src-haskell">newtype Identity a = Identity { runIdentity :: a }

instance Monad Identity where
    return = Identity
    i &gt;&gt;= f = f $ runIdentity i
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-4" class="outline-4">
<h4 id="sec-1-5-4"><span class="section-number-4">1.5.4</span> <span class="done DONE">DONE</span> Either monad</h4>
<div class="outline-text-4" id="text-1-5-4">
<div class="org-src-container">

<pre class="src src-haskell">data Either a b = Left a | Right b
Either :: * &rarr; * &rarr; *

instance Monad (Either a) where
    return = Right
    Left l &gt;&gt;= _  = Left l
    Right r &gt;&gt;= f = f r
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-5" class="outline-4">
<h4 id="sec-1-5-5"><span class="section-number-4">1.5.5</span> <span class="done DONE">DONE</span> Monad composition</h4>
<div class="outline-text-4" id="text-1-5-5">
<div class="org-src-container">

<pre class="src src-haskell">(.) :: (b &rarr; c) &rarr; (a &rarr; b) &rarr; a &rarr; c
(&lt;=&lt;) :: Monad m &rArr; (b &rarr; m c) &rarr; (a &rarr; m b) &rarr; a &rarr; m c
(&gt;=&gt;) :: Monad m &rArr; (a &rarr; m b) &rarr; (b &rarr; m c) &rarr; a &rarr; m c

m &gt;&gt;= (f &gt;=&gt; g) == m &gt;&gt;= f &gt;&gt;= g
m &gt;&gt;= (f &lt;=&lt; g) == m &gt;&gt;= g &gt;&gt;= f
(f &gt;=&gt; g) &gt;=&gt; h == f &gt;=&gt; (g &gt;=&gt; h) -- associativity

safeTail :: [a] &rarr; Maybe [a]
safeInit :: [a] &rarr; Maybe [a]
safeStrip :: [a] &rarr; Maybe [a]
safeStrip = safeTail &gt;=&gt; safeInit
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-6" class="outline-4">
<h4 id="sec-1-5-6"><span class="section-number-4">1.5.6</span> <span class="done DONE">DONE</span> List monad</h4>
<div class="outline-text-4" id="text-1-5-6">
<div class="org-src-container">

<pre class="src src-haskell">instance Monad [] where
    return x = [x]
    l &gt;&gt;= f = concat (map f l)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-7" class="outline-4">
<h4 id="sec-1-5-7"><span class="section-number-4">1.5.7</span> <span class="done DONE">DONE</span> Join</h4>
<div class="outline-text-4" id="text-1-5-7">
<div class="org-src-container">

<pre class="src src-haskell">join :: Monad m &rArr; m (m a) &rarr; m a
join [[1,2],[3,4]] -- [1,2,3,4]
join Just (Just 5) -- Just 5
</pre>
</div>
<p>
<code>extract :: Monad m &rArr; m a &rarr; a</code> не можем определить, так как не
всегда можем вытащить значение из монады. Например, не очень
понятно, что делать в таком случае:
</p>
<div class="org-src-container">

<pre class="src src-haskell">extract :: Maybe Int &rarr; Int
extract Just x = x
extract Nothing = ???
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-5-8" class="outline-4">
<h4 id="sec-1-5-8"><span class="section-number-4">1.5.8</span> <span class="done DONE">DONE</span> Полезные функции для монад</h4>
<div class="outline-text-4" id="text-1-5-8">
<ol class="org-ol">
<li><code>Control.Monad</code>:
</li>
</ol>
<div class="org-src-container">

<pre class="src src-haskell">liftM :: Monad m &rArr; (a &rarr; b) &rarr; m a &rarr; m b
liftM2 :: Monad m &rArr; (a &rarr; b &rarr; c) &rarr; m a &rarr; m b &rarr; m c
liftM2 (+) (Just 1) (Just 2) -- Just 3
maybePair = liftM2 (,)
</pre>
</div>
<ol class="org-ol">
<li><code>Control.Monad.Extra</code>:
</li>
</ol>
<div class="org-src-container">

<pre class="src src-haskell">ifM :: Monad m &rArr; m Bool &rarr; m a &rarr; m a &rarr; m a
(||^) :: Monad m &rArr; m Bool &rarr; m Bool &rarr; m Bool
Just False ||^ Just True -- Just True
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> <span class="done DONE">DONE</span> <code>[10/10]</code> Lecture 6: Functors, Applicative Functors</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1"><span class="section-number-4">1.6.1</span> <span class="done DONE">DONE</span> Functor</h4>
<div class="outline-text-4" id="text-1-6-1">
<div class="org-src-container">

<pre class="src src-haskell">class Functor f where -- f :: * &rarr; *
    fmap :: (a &rarr; b) &rarr; f a &rarr; f b
    (&lt;$) :: a &rarr; f b &rarr; f a

3 &lt;$ Just 5 -- Just 3

instance Functor Maybe where
    fmap f (Just x) = Just f x
    fmap _ Nothing  = Nothing

(&lt;$&gt;) :: Functor f &rArr; (a &rarr; b) &rarr; f a &rarr; f b
(&lt;$&gt;) = fmap

instance Functor [] where
    fmap = map

instance Functor ((&rarr;) r) where
    fmap = (.)

let foo = fmap (+3) (+2)
foo 10 -- 15
</pre>
</div>
<p>
Законы функтора:
</p>
<ol class="org-ol">
<li><code>fmap id == id</code>
</li>
<li><code>fmap (f . g) == fmap f . fmap g</code>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-6-2" class="outline-4">
<h4 id="sec-1-6-2"><span class="section-number-4">1.6.2</span> <span class="done DONE">DONE</span> Bifunctor</h4>
<div class="outline-text-4" id="text-1-6-2">
<div class="org-src-container">

<pre class="src src-haskell">class Bifunctor p where
    bimap  :: (a &rarr; b) &rarr; (c &rarr; d) &rarr; p a c &rarr; p b d

    first  :: (a &rarr; b)           &rarr; p a c &rarr; p b c
    second ::           (b &rarr; c) &rarr; p a b &rarr; p a c

instance Bifunctor (,) where
    bimap f g (a, b) = (f a, g b)

instance Bifunctor Either where
    bimap f _ (Left a)  = Left (f a)
    bimap _ g (Right b) = Right (g b)

instance Bifunctor (&rarr;) where -- не определен вроде как
</pre>
</div>
<p>
Законы бифунктора:
</p>
<ol class="org-ol">
<li><code>bimap id == id</code>; <code>first id == id</code>; <code>second id == id</code>
</li>
<li><code>bimap f g == first f . second g</code>
</li>
<li><code>bimap (f . g) (h . i) == bimap f h . bimap g i</code>; <code>first (f . g) == first f . first g</code>; <code>second (h . i) == second h . second i</code>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-6-3" class="outline-4">
<h4 id="sec-1-6-3"><span class="section-number-4">1.6.3</span> <span class="done DONE">DONE</span> Applicative</h4>
<div class="outline-text-4" id="text-1-6-3">
<div class="org-src-container">

<pre class="src src-haskell">class Functor f &rArr; Applicative f where
    pure :: a &rarr; f a
    (&lt;*&gt;) :: f (a &rarr; b) &rarr; f a &rarr; f b

    (*&gt;) :: f a &rarr; f b &rarr; f b
    (&lt;*) :: f a &rarr; f b &rarr; f a

instance Applicative Maybe where
    pure x = Just x
    Nothing &lt;*&gt; _ = Nothing
    Just f &lt;*&gt; x  = fmap f x

instance Applicative [] where
    pure x = [x]
    fs &lt;*&gt; xs = [f x | f &larr; fs, x &larr; xs]

newtype ZipList a = ZipList { getZipList :: [a] }

instance Applicative ZipList where
    pure x = ZipList (repeat x)
    ZipList fs &lt;*&gt; ZipList xs = ZipList (zipWith id fs xs)

instance Applicative ((&rarr;) r) where
    pure x = \_ &rarr; x
    f &lt;*&gt; g = \x &rarr; f x (g x)

-- Examples
(pure 3) "blah" -- 3
(+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5 -- 508
(\x y z &rarr; [x,y,z]) &lt;$&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (/2) $ 5 -- [8.0,10.0,2.5]
</pre>
</div>
<p>
Законы аппликатива:
</p>
<ol class="org-ol">
<li><code>pure id &lt;*&gt; v == v</code> - identity
</li>
<li><code>pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w == u &lt;*&gt; (v &lt;*&gt; w)</code> - composition
</li>
<li><code>pure f &lt;*&gt; pure x == pure (f x)</code> - homomorphism
</li>
<li><code>u &lt;*&gt; pure y == pure ($ y) &lt;*&gt; u</code> - interchange
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-6-4" class="outline-4">
<h4 id="sec-1-6-4"><span class="section-number-4">1.6.4</span> <span class="done DONE">DONE</span> liftAN и стиль программирования с аппликативами</h4>
<div class="outline-text-4" id="text-1-6-4">
<div class="org-src-container">

<pre class="src src-haskell">liftA2 :: Applicative f &rArr; (a &rarr; b &rarr; c) &rarr; f a &rarr; f b &rarr; f c
liftA3 :: Applicative f &rArr; (a &rarr; b &rarr; b &rarr; d) &rarr; f a &rarr; f b &rarr; f c &rarr; f d

(*) &lt;$&gt; Just 5 &lt;*&gt; Just 3 -- Just 15
liftA2 (*) (Just 5) (Just 3) -- Just 15

isUpperOrDigit :: Char &rarr; Bool
isUpperOrDigit = liftA2 (||) isUpper isDigit

isUpperOrDigit 'A' -- True
isUpperOrDigit '3' -- True
isUpperOrDigit 'a' -- False

-- Программирование с аппликативами
data User = User { userFirstName :: String
                 , userLastName :: String
                 , userEmail :: String
                 }

type Profile = [(String, String)]

profileExample = [("first_name", "Pat"),("last_name", "Brisbin"),("email", "me@a.com")]
lookup "first_name" p :: Maybe String

buildUser :: Profile &rarr; Maybe User
buildUser p = User
    &lt;$&gt; lookup "first_name" p
    &lt;*&gt; lookup "last_name" p
    &lt;*&gt; lookup "email" p

buildUser' :: Profile &rarr; Maybe User
buildUser' p = liftA3 User
                      (lookup "first_name" p)
                      (lookup "last_name" p)
                      (lookup "email" p)

buildUser'' :: Profile &rarr; Maybe User
buildUser'' = liftA3 (liftA3 User)
                     (lookup "first_name")
                     (lookup "last_name")
                     (lookup "email")
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-5" class="outline-4">
<h4 id="sec-1-6-5"><span class="section-number-4">1.6.5</span> <span class="done DONE">DONE</span> Alternative</h4>
<div class="outline-text-4" id="text-1-6-5">
<div class="org-src-container">

<pre class="src src-haskell">class Applicative f &rArr; Alternative f where
    empty :: f a
    (&lt;|&gt;) :: f a &rarr; f a &rarr; f a

instance Alternative Maybe where
    empty = Nothing
    Nothing &lt;|&gt; r = r
    l &lt;|&gt; _       = l

instance Alternative [] where
    empty = []
    (&lt;|&gt;) = (++)

Nothing &lt;|&gt; Just 3 &lt;|&gt; empty &lt;|&gt; Just 5 -- Just 3
[] &lt;|&gt; [1,2,3] &lt;|&gt; [4] -- [1,2,3,4]

guard :: (Alternative f) &rArr; Bool &rarr; f ()
guard True  = pure ()
guard False empty

evenPair :: (Alternative m, Monad m, Integral a, Integral b) &rArr; m a &rarr; m b &rarr; m (a, b)
evenPair a b =
    a &gt;&gt;= \x &rarr;
    b &gt;&gt;= \y &rarr;
    guard (even x &amp;&amp; even y) &gt;&gt;
    return (x, y)

evenPair (Just 2) (Just 4) -- Just (2, 4)
evenPair (Just 2) (Just 5) -- Nothing
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-6" class="outline-4">
<h4 id="sec-1-6-6"><span class="section-number-4">1.6.6</span> <span class="done DONE">DONE</span> List comprehension sugar</h4>
<div class="outline-text-4" id="text-1-6-6">
<div class="org-src-container">

<pre class="src src-haskell">sweetPythags = [(x,y,z) | z &larr; [1..], x &larr; [1..z], y &larr; [x..z], x^2 + y^2 == z^2]
take 2 sweetPythags -- [(3,4,5),(6,8,10)]

pythagsWithoutSugar =
    [1..] &gt;&gt;= \z &rarr;
    [1..z] &gt;&gt;= \x &rarr;
    [x..z] &gt;&gt;= \y &rarr;
    guard (x^2 + y^2 == z^2) &gt;&gt;
    return (x,y,z)

take 2 pythagsWithoutSugar -- [(3,4,5),(6,8,10)]
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-7" class="outline-4">
<h4 id="sec-1-6-7"><span class="section-number-4">1.6.7</span> <span class="done DONE">DONE</span> Traversable type class</h4>
<div class="outline-text-4" id="text-1-6-7">
<div class="org-src-container">

<pre class="src src-haskell">class (Functor t, Foldable t) &rArr; Traversable t where
    traverse :: Applicative f &rArr; (a &rarr; f b) &rarr; t a &rarr; f (t b)
    sequenceA :: Applicative f &rArr; t (f a) &rarr; f (t a)

instance Traversable Maybe where
    traverse _ Nothing = Nothing
    traverse f (Just x) = Just &lt;$&gt; f x

instance Traversable [] where
    traverse f = foldr consF (pure [])
      where
        consF x ys = (:) &lt;$&gt; f x &lt;*&gt; ys

half x = if even x then Just (x `div` 2) else Nothing
traverse half [2, 4..10] -- Just [1,2,3,4,5]
traverse half [1..10] -- Nothing

rep x = replicate x x
traverse rep [1..3] -- [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
</pre>
</div>
<p>
Есть еще <code>Bifoldable</code> и <code>Bitraversable</code> по аналогии с <code>Bifunctor</code>.
</p>
</div>
</div>
<div id="outline-container-sec-1-6-8" class="outline-4">
<h4 id="sec-1-6-8"><span class="section-number-4">1.6.8</span> <span class="done DONE">DONE</span> Automatic deriving (Functor, Foldable, Traversable)</h4>
<div class="outline-text-4" id="text-1-6-8">
<p>
Можно автоматически "отнаследовать" <code>Functor</code>, <code>Foldable</code> и
<code>Traversable</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">{-# LANGUAGE DeriveFunctor #-} -- generates `fmap`
{-# LANGUAGE DeriveFoldable #-} -- generates `foldr` and `foldMap`
{-# LANGUAGE DeriveTraversable #-} -- generates `traverse`

data Tree a = Left | Node a (Tree a) (Tree a)
    deriving (Functor, Foldable, Traversable)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-6-9" class="outline-4">
<h4 id="sec-1-6-9"><span class="section-number-4">1.6.9</span> <span class="done DONE">DONE</span> <code>[4/4]</code> Type hierarchy proposals</h4>
<div class="outline-text-4" id="text-1-6-9">
</div>
<ol class="org-ol"><li><a id="sec-1-6-9-1" name="sec-1-6-9-1"></a><span class="done DONE">DONE</span> AMP (Applicative/Monad proposal)<br  /><div class="outline-text-5" id="text-1-6-9-1">
<p>
Раньше аппликатив не был суперклассом монады, было много споров
на эту тему и все такое. В итоге с так называемым AMP с версии
<code>GHC 7.8.1</code> аппликатив стал суперклассом монады:
</p>
<div class="org-src-container">

<pre class="src src-haskell">class Applicative m &rArr; Monad m where
    ...
</pre>
</div>
<p>
Как можно мигрировать существующий код:
</p>
<div class="org-src-container">

<pre class="src src-haskell">instance Applicative MyDataType where
    pure = return
    (&lt;*&gt;) = ap
</pre>
</div>
</div>
</li>
<li><a id="sec-1-6-9-2" name="sec-1-6-9-2"></a><span class="done DONE">DONE</span> FTP (Foldable/Traversable proposal)<br  /><div class="outline-text-5" id="text-1-6-9-2">
<p>
Если коротко, то суть в том, что взяли методы для списка из
<code>Prelude</code> и заменили их более общими методами с <code>Foldable</code> и
<code>Traversable</code>. И еще добавили методов из <code>Control.Monad</code>, тоже
поменяв где-то на <code>Foldable</code> и <code>Traversable</code> списки. Собственно:
</p>
<div class="org-src-container">

<pre class="src src-haskell">-- replace such functions and some others
length :: [a] &rarr; Int
null :: [a] &rarr; Bool
foldr :: (a &rarr; b &rarr; b) &rarr; b &rarr; [a] &rarr; b

-- with
lenght :: Foldable f &rArr; f a &rarr; Int
null :: Foldable f &rArr; f a &rarr; Bool
foldr :: Foldable f &rArr; (a &rarr; b &rarr; b) &rarr; b &rarr; f a &rarr; b
</pre>
</div>
<p>
Из плюсов - теперь можно использовать для <code>List</code>, <code>Set</code>, <code>Map</code>,
<code>Maybe</code> и т.д. Из минусов - такие спецэффекты:
<code>length (1, 2) == 1</code>
</p>
</div>
</li>
<li><a id="sec-1-6-9-3" name="sec-1-6-9-3"></a><span class="done DONE">DONE</span> MRP (Monad of no return/&gt;&gt; proposal)<br  /><div class="outline-text-5" id="text-1-6-9-3">
<p>
Тут предлагается вынести нафиг из монады <code>return</code> и <code>&gt;&gt;</code>. Внести
их в <code>Prelude</code> с ограничением <code>Applicative</code>. Сейчас:
</p>
<div class="org-src-container">

<pre class="src src-haskell">class Applicative m &rArr; Monad m where
    (&gt;&gt;=) :: m a &rarr; (a &rarr; m b) &rarr; m b
    return :: a &rarr; m a
    return = pure

    (&gt;&gt;) :: m a &rarr; m b &rarr; m b
    m &gt;&gt; k = m &gt;&gt;= \_ &rarr; k
</pre>
</div>
<p>
Предлагается:
</p>
<div class="org-src-container">

<pre class="src src-haskell">class Applicative m &rArr; Monad m where
    (&gt;&gt;=) :: m a &rarr; (a &rarr; m b) &rarr; m b

return :: Applicative f &rArr; a &rarr; f a
return = pure

(&gt;&gt;) :: Applicative f &rArr; f a &rarr; f b &rarr; f b
(&gt;&gt;) = (*&gt;)
</pre>
</div>
</div>
</li>
<li><a id="sec-1-6-9-4" name="sec-1-6-9-4"></a><span class="done DONE">DONE</span> MFP (MonadFail proposal)<br  /><div class="outline-text-5" id="text-1-6-9-4">
<p>
Все просто. Выпилить <code>fail</code> из монады, создать новый класс
типов <code>MonadFail</code> и впихнуть туда <code>fail</code>. Сейчас:
</p>
<div class="org-src-container">

<pre class="src src-haskell">class Applicative m &rArr; Monad m where
    ...
    fail :: String &rarr; m a
</pre>
</div>
<p>
Предлагается:
</p>
<div class="org-src-container">

<pre class="src src-haskell">class Applicative m &rArr; Monad m where
    ...

class Monad m &rArr; MonadFail m where
    fail :: String &rarr; m a
</pre>
</div>
</div>
</li></ol>
</div>
<div id="outline-container-sec-1-6-10" class="outline-4">
<h4 id="sec-1-6-10"><span class="section-number-4">1.6.10</span> <span class="done DONE">DONE</span> Type classes hierarchy</h4>
<div class="outline-text-4" id="text-1-6-10">
<p>
<a href="images/Type classes hierarchy diagram.png">Diagram</a>
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> <span class="done DONE">DONE</span> <code>[7/7]</code> Lecture 7: Monads, part 2</h3>
<div class="outline-text-3" id="text-1-7">
</div>
<div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1"><span class="section-number-4">1.7.1</span> <span class="done DONE">DONE</span> Writer monad</h4>
<div class="outline-text-4" id="text-1-7-1">
<div class="org-src-container">

<pre class="src src-haskell">newtype Writer w a = Writer { runWriter :: (a, w) } -- a - значение, w - лог

instance Monoid m &rArr; Monad (Writer w) where
    return a = Writer (a, mempty)
    Writer (x, v) &gt;&gt;= f = let Writer (y, v') = f x
                          in Writer (y, v `mappend` v')

tell :: w &rarr; Writer w ()
execWriter :: Writer w a &rarr; w
writer :: (a, w) &rarr; Writer w a

binPow :: Int &rarr; Int &rarr; Writer String Int
binPow 0 _ = return 1
binPow n a
    | even n    = binPow (n `div` 2) a &gt;&gt;= \b &rarr;
                  tell ("Square " ++ show b ++ "\n") &gt;&gt;
                  return (b * b)
    | otherwise = binPow (n - 1) a &gt;&gt;= \b &rarr;
                  tell ("Mul " ++ show a ++ " and " ++ show b ++ "\n") &gt;&gt;
                  return (a * b)

binPow n a
    | even n    = binPow (n `div` 2) a &gt;&gt;= \b &rarr;
                  writer (b * b, "Square " ++ show b ++ "\n")
    | otherwise = binPow (n - 1) a &gt;&gt;= \b &rarr;
                  writer (a * b, "Mul " ++ show a ++ " and " ++ show b ++ "\n")
</pre>
</div>
<p>
Есть некий трюк с монадой <code>Writer</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">listTellExample :: Writer [Int] ()
listTellExample = tell [1] &gt;&gt; tell[2] &gt;&gt; tell[3]

execWriter listTellExample -- [1,2,3]

-- Можно сделать так:
tell' :: a &rarr; Writer [a] ()
tell' = tell . (:[])

listTell'Example :: Writer [Int] ()
listTell'Example = tell' 1 &gt;&gt; tell' 2 &gt;&gt; tell' 3

execWriter listTell'Example -- [1,2,3]
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-2" class="outline-4">
<h4 id="sec-1-7-2"><span class="section-number-4">1.7.2</span> <span class="done DONE">DONE</span> Reader monad</h4>
<div class="outline-text-4" id="text-1-7-2">
<div class="org-src-container">

<pre class="src src-haskell">newtype Reader e a = Reader { runReader :: e &rarr; a }

ask :: Reader e e
asks :: (e &rarr; a) &rarr; Reader e a
local :: (e &rarr; b) &rarr; Reader b a &rarr; Reader e a

instance Monad (Reader e) where
    return a = Reader $ \_ &rarr; a
    m &gt;&gt;= f = Reader $ \r &rarr; runReader (f $ runReader m r) r

data Environment = Environment { name :: String
                               , ids :: [Int]
                               , manager :: String &rarr; String
                               }

containsId :: Int &rarr; Reader Environment Bool
containsId i = asks (\env &rarr; i `elem` ids env)

safeCallManager :: Int &rarr; Reader Environment (Maybe String)
safeCallManager i = containsId i &gt;&gt;= \hasId &rarr;
                    if hasId
                    then asks (\env &rarr; Just $ manager env $ name env)
                    else return Nothing

runReader (safeCallManager 1) $ Environment "Ivan" [1,3] ("Hi, " ++) -- Just "Hi, Ivan"
runReader (safeCallManager 2) $ Environment "Ivan" [1,3] ("Hi, " ++) -- Nothing
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-3" class="outline-4">
<h4 id="sec-1-7-3"><span class="section-number-4">1.7.3</span> <span class="done DONE">DONE</span> Typed holes</h4>
<div class="outline-text-4" id="text-1-7-3">
<p>
Сначала немного абстрактных слов. Суть в том, что используя
полиморфные типы, мы порой во время написания функции хотим
узнать, как все они должны сочетаться. Мы хотим, чтобы компилятор
мог нам с этим помочь. Чем-то это похоже на <code>undefined</code>. Во время
компиляции там, где стоят typed holes компилятор говорит, какой
он хочет там тип. Еще он скажет, какие есть доступные
“типо переменные” в данном контексте. Теперь пример:
</p>
<div class="org-src-container">

<pre class="src src-haskell">data Free f a = Pure a | Free (f (Free f a))


instance Functor f &rArr; Monad (Free f) where
    return = Pure
    Pure a &gt;&gt;= f = f a
    Free f &gt;&gt;= g = Free _

{-
Компилятор скажет такое:
Found hole '_' with type f (Free f b)
  Where: 'f' if a rigid type variable bound by
             the instance declaration at holes.hs:26:10
         'b' is a rigid type variable bound by
             the type signature for
                 &gt;&gt;= :: Free f a &rarr; (a &rarr; Free f b) &rarr; Free f b
             at FreeMonad.hs:10:10
  Relevant bindings include
    &gt;&gt;= :: Free f a &rarr; (a &rarr; Free f b) &rarr; Free f b (bound at FreeMonad.hs:11:3)
    f :: f (Free f a) (bound at FreeMonad.hs:11:8)
    g :: a &rarr; Free f b (bound at FreeMonad.hs:11:14)
  In the first argument of 'Free', namely '_'
  In the expression: Free (_)
  In an equation for '&gt;&gt;=': (Free f) &gt;&gt;= g = Free (_)
-}

-- Теперь мы лучше представляем, что надо подставить на место '_'
    Free f &gt;&gt;= g = Free (fmap _ f)

{-
Found hole '_' with type Free f a &rarr; Free f b
  (&gt;&gt;=) :: Free f a &rarr; (a &rarr; Free f b) &rarr; Free f b
  g ::                 a &rarr; Free f b
-}

    Free f &gt;&gt;= g = Free (fmap (&gt;&gt;= g) f)

-- Вот и готово
</pre>
</div>
<p>
Types holes должны начинаться с <code>_</code>. Еще примеры попроще:
</p>
<div class="org-src-container">

<pre class="src src-haskell">foo :: a &rarr; b
foo x = _
-- Found hole '_' with type: b

bar :: [Int]
bar = map _f ["aba","caba"]
-- Found hole '_f' with type: [Char] &rarr; Int

mfold :: [Maybe a] &rarr; [Either a b]
mfold = foldr _f _z
-- Found hole '_f' with type: Maybe a &rarr; [Either a b] &rarr; [Either a b]
-- Found hole '_z' with type: [Either a b]

join :: m (m a) &rarr; m a
join m = m &gt;&gt;= _
-- Found hole '_' with type: m a &rarr; m a
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-4" class="outline-4">
<h4 id="sec-1-7-4"><span class="section-number-4">1.7.4</span> <span class="done DONE">DONE</span> Partial type signatures</h4>
<div class="outline-text-4" id="text-1-7-4">
<p>
Можно указывать wildcard-ы в описаниях типов функций, если в начале
написать <code>{-# LANGUAGE PartialTypeSignatures #-}</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">foo :: _ &rarr; Bool
foo x = not x
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-5" class="outline-4">
<h4 id="sec-1-7-5"><span class="section-number-4">1.7.5</span> <span class="done DONE">DONE</span> State monad</h4>
<div class="outline-text-4" id="text-1-7-5">
<p>
Изменение состояния во время вычислений. В императивных языках просто
меняем значение переменной. В функциональных языках создаем
новую переменную с новым значением. Мотивирующий кейс для монады <code>State</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">type Stack = [Int]

pop :: Stack &rarr; (Int, Stack)
push :: Int &rarr; Stack &rarr; Stack
pop (x:xs) = (x, xs)
push x s = x:s

push :: Int &rarr; Stack &rarr; ((), Stack)
push x s = ((), x:s)

stackOps :: Stack &rarr; (Int, Stack)
stackOps s = let (x, xs)  = pop s
                 (_, s')  = push 5 xs
                 (_, res) = push 10 s'
             in (x, res)

stackOps [1,2,3] -- (1,[10,5,2,3])
</pre>
</div>
<p>
Помощь - монада <code>State</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">-- import Control.Monad.State

newtype State s a = State { runState :: s &rarr; (a, s) }

instance Monad (State s) where
    return a = State $ \s &rarr; (a, s)
    oldState &gt;&gt;= f = State $ \s &rarr; let (a, newState) = runState oldState s
                                  in runState (f a) newState
</pre>
</div>
<p>
Вот теперь напишем нашу реализацию стека, используя монаду <code>State</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">type Stack = [Int]

pop :: State Stack Int
pop = state $ \(x:xs) &rarr; (x, xs)

push :: Int &rarr; State Stack ()
push x = state $ \xs &rarr; ((), x:xs)

stackOps :: State Stack Int
stackOps = pop &gt;&gt;= \x &rarr; push 5 &gt;&gt; push 10 &gt;&gt; return x
</pre>
</div>
<p>
Пример с обходом в глубину:
</p>
<div class="org-src-container">

<pre class="src src-haskell">type Vertex = Int
type Graph = [[Vertex]]

dfs :: Vertex &rarr; Vertex &rarr; Graph &rarr; Bool
dfs from to graph = evalState (reach from) []
  where
    -- state represented as list of visited vertices
    reach :: Vertex &rarr; State [Vertex] Bool
    reach v
        | v == to   = return True
        | otherwise = get &gt;&gt;= \visited &rarr;
                      if v `elem` visited
                      then return False
                      else put (v:visited) &gt;&gt;
                           or &lt;$&gt; mapM reach (graph !! v)
</pre>
</div>
<p>
Полезные функции:
</p>
<dl class="org-dl">
<dt> ~get </dt><dd>State s s~
</dd>
<dt> ~put </dt><dd>s &rarr; State s ()~
</dd>
<dt> ~modify </dt><dd>(s &rarr; s) &rarr; State s ()~
</dd>
<dt> ~gets </dt><dd>(s &rarr; a) &rarr; State s a~
</dd>
<dt> ~withState </dt><dd>(s &rarr; s) &rarr; State s a &rarr; State s a~
</dd>
<dt> ~evalState </dt><dd>State s a &rarr; s &rarr; a~
</dd>
<dt> ~execState </dt><dd>State s a &rarr; s &rarr; a~
</dd>
</dl>
</div>
</div>
<div id="outline-container-sec-1-7-6" class="outline-4">
<h4 id="sec-1-7-6"><span class="section-number-4">1.7.6</span> <span class="done DONE">DONE</span> RWS monad</h4>
<div class="outline-text-4" id="text-1-7-6">
<div class="org-src-container">

<pre class="src src-haskell">newtype RWS r w s a = RWST { runRWS :: r &rarr; s &rarr; (a, s, w) }

-- now
runRWS :: RWS r w s a &rarr; r &rarr; s &rarr; (a, s, w)
execRWS :: RWS r w s a &rarr; r &rarr; s &rarr; (s, w)
evalRWS :: TES r w s a &rarr; r &rarr; s &rarr; (a, w)

import Control.Monad.RWS

type R = Int
type W = [Int]
type S = Int

computation :: RWS R W S ()
computation = do e &larr; ask
                 a &larr; get
                 let b = a + e
                 put b
                 tell [b]

example = runRWS computation 2 3
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-7-7" class="outline-4">
<h4 id="sec-1-7-7"><span class="section-number-4">1.7.7</span> <span class="done DONE">DONE</span> Cont monad and Continuation Passing Style (CPS)</h4>
<div class="outline-text-4" id="text-1-7-7">
<p>
Для анонимных callback-ов:
</p>
<div class="org-src-container">

<pre class="src src-haskell">square :: Int &rarr; Int
square x = x * x

pythagoras :: Int &rarr; Int &rarr; Int
pythagoras x y = (+) (square x) (square y)

addCPS :: Int &rarr; Int &rarr; ((Int &rarr; r) &rarr; r)
addCPS x y = \k &rarr; k (x + y)

squareCPS :: Int &rarr; ((Int &rarr; r) &rarr; r)
squareCPS x = \k &rarr; k (square x)

pythagorasCPS :: Int &rarr; Int &rarr; ((Int &rarr; r) &rarr; r)
pythagorasCPS x y = \k &rarr; -- k :: (Int &rarr; r) &rarr; r
    squareCPS x $ \x2 &rarr;
    squareCPS y $ \y2 &rarr;
    addCPS x2 y2 $ k -- addCPS x2 y2 :: (Int &rarr; r) &rarr; r

pythagorasCPS 3 4 id -- 25

map ($ 2) [(3*),(2+),(1-)] -- [6,4,-1]

-- Now with Cont

newtype Cont r a = Cont { runCont :: (a &rarr; r) &rarr; r }
cont :: ((a &rarr; r) &rarr; r) &rarr; Cont r a

runCont (cont ($ 2)) `map` [(3*),(2+),(1-)] -- [6,4,-1]
runCont (cont ($ 2)) id -- 2

addCPS :: Int &rarr; Int &rarr; Cont r Int
addCPS x y = cont $ \k &rarr; k (x + y)

squareCPS :: Int &rarr; Cont r Int
squareCPS x = cont $ \k &rarr; k (square x)

pythagorasCPS :: Int &rarr; Int &rarr; Cont r Int
pythagorasCPS x y = cont $ \k &rarr;
    runCont (squareCPS x) $ \x2 &rarr;
    runCont (squareCPS y) $ \y2 &rarr;
    runCont (addCPS x2 y2) $ k

runCont (pythagorasCPS 3 4) id -- 25

-- Now with Cont Monad

newtype Cont r a = Cont { runCont :: (a &rarr; r) &rarr; r }

instance Monad (Cont r) where
    return a = Cont ($ a)
    Cont arr &gt;&gt;= f = Cont $ \br &rarr; arr $ \a &rarr; runCont (f a) br

    -- arr :: (a &rarr; r) &rarr; r
    -- br  :: (b &rarr; r)
    -- f   :: a &rarr; Cont r b

addCPS :: Int &rarr; Int &rarr; Cont r Int
addCPS x y = return $ x + y

squareCPS :: Int &rarr; Cont r Int
squareCPS = return . square

pythagorasCPS :: Int &rarr; Int &rarr; Cont r Int
pythagorasCPS x y = squareCPS x &gt;&gt;= \x2 &rarr;
                    squareCPS y &gt;&gt;= \y2 &rarr;
                    addCPS x2 y2
</pre>
</div>
<p>
Круто для:
</p>
<ol class="org-ol">
<li>Представления программы для компилятора
</li>
<li>Введения callback-ов
</li>
<li>Оптимизации хвостовой рекурсии
</li>
<li>Обработки ошибок
</li>
<li>Построения подпрограмм
</li>
</ol>
<div class="org-src-container">

<pre class="src src-haskell">class Monad m &rArr; MonadCont m where
    callCC :: ((a &rarr; m b) &rarr; m a) &rarr; m a -- call-with-current-continuation

instance MonadCont (Cont r) where
    callCC :: ((a &rarr; Cont r b) &rarr; Cont r a) &rarr; Cont r a
    callCC f = cont $ \c &rarr; runCont (f (\x &rarr; cont $ \_ &rarr; c x)) c
</pre>
</div>
<p>
<code>callCC</code> дает нам обратно явный контроль над continuations:
</p>
<div class="org-src-container">

<pre class="src src-haskell">foo :: Int &rarr; Cont r String
foo x = callCC $ \earlyReturn &rarr;
    let y = x ^ 2 + 3 in
    when (y &gt; 20) (earlyReturn "over twenty") &gt;&gt;
    return (show $ y - 4)

runCont (foo 2) putStrLn -- 3
runCont (foo 10) putStrLn -- over twenty
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> <span class="done DONE">DONE</span> <code>[8/8]</code> Lecture 8: RealWorld</h3>
<div class="outline-text-3" id="text-1-8">
</div>
<div id="outline-container-sec-1-8-1" class="outline-4">
<h4 id="sec-1-8-1"><span class="section-number-4">1.8.1</span> <span class="done DONE">DONE</span> Building IO system from scratch</h4>
<div class="outline-text-4" id="text-1-8-1">
<p>
Хаскель является чистым языком, поэтому не очень понятно, как сделать <code>getchar()</code>,
как в плюсах, например. Попробуем сделать сами:
</p>
<div class="org-src-container">

<pre class="src src-haskell">getchar :: Char
get2chars = [getchar, getchar]
</pre>
</div>
<p>
Проблемы:
</p>
<ol class="org-ol">
<li>Поскольку хаскель - чистый язык, то компилятор может просто
</li>
</ol>
<p>
забить на второй вызов функции <code>getchar</code> и взять значение из
первого вызова.
</p>
<ol class="org-ol">
<li>Даже если вызова будет 2, все равно мы не знаем, в каком
</li>
</ol>
<p>
порядке эти две функции будут вызваны.
Решение:
</p>
<ul class="org-ul">
<li>Введем фейковый параметр для <code>getchar</code>, чтобы компилятор считал
</li>
</ul>
<p>
все вызовы разными.
</p>
<div class="org-src-container">

<pre class="src src-haskell">getchar :: Int &rarr; Char

get2chars = [getchar 1, getchar 2]
</pre>
</div>
<p>
Это решает первую проблему. Еще надо, чтобы <code>get2chars</code> тоже имел
фейковый параметр, чтобы у него не было той же проблемы:
</p>
<div class="org-src-container">

<pre class="src src-haskell">getchar :: Int &rarr; Char
get2chars :: Int &rarr; String

get2chars _ = [getchar 1, getchar 2]
</pre>
</div>
<p>
Теперь надо решить вторую проблему. Хаскель не дает никакого
способа задать порядок вычислений, кроме зависимостей. Тогда
добавим искусственную зависимость, которая не даст вычислиться
второму <code>getchar</code>, пока не вычислится первый. Для этого будем
из <code>getchar</code> возвращать фейковый результат, который будет
использоваться как параметр для второго вызова <code>getchar</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">getchar :: Int &rarr; (Char, Int)

get2chars _ = [a,b] where (a, i) = getchar 1
                          (b, _) = getchar i
</pre>
</div>
<p>
Теперь мы гарантируем, что <code>a</code> будет прочитано перед <code>b</code>, потому
что для чтения <code>b</code> необходимо значение <code>i</code>, которое возвращается,
когда читается значение <code>a</code>.
Проблема:
</p>
<ul class="org-ul">
<li>Компилятор слишком умный. Он может поверить, что внешняя функция
</li>
</ul>
<p>
<code>getchar</code> действительно зависит от параметра, но для <code>get2chars</code> такай
трюк уже не работает, компилятор увидит, что мы читерим, потому что
забиваем на параметр. Поэтому он не обязан исполнять вызовы в том порядке,
в котором нам нужно.
Решение:
</p>
<ul class="org-ul">
<li>Давайте подсунем фейковый параметр от <code>get2chars</code> в первый вызов
</li>
</ul>
<p>
<code>getchar</code>. В этом случае компилятор не догадается, что этот параметр не
используется.
</p>
<div class="org-src-container">

<pre class="src src-haskell">get2chars i0 = [a,b] where (a, i1) = getchar i0
                           (b, i2) = getchar i1
</pre>
</div>
<p>
Проблема:
</p>
<ul class="org-ul">
<li>Теперь такая же проблема преследует <code>get2chars</code>. Если нужно вызвать
</li>
</ul>
<p>
2 раза, нужно определить порядок вызовов. Плохой случай:
</p>
<div class="org-src-container">

<pre class="src src-haskell">get4chars = [get2chars 1, get2chars 2] -- order of 'get2chars' calls isn't defined
</pre>
</div>
<p>
Решение:
</p>
<ul class="org-ul">
<li>Решим таким же образом, как и с <code>getchar</code>. Пусть <code>get2chars</code> тоже
</li>
</ul>
<p>
возвращает фейковое значение, которое может быть использовано в других
вызовах.
</p>
<div class="org-src-container">

<pre class="src src-haskell">get2chars :: Int &rarr; (String, Int)
get2chars i0 = ([a,b], i2) where (a, i1) = getchar i0
                                 (b, i2) = getchar i1

get4chars i0 = (a ++ b) where (a, i1) = get2chars i0
                              (b, i2) = get2chars i1
</pre>
</div>
<p>
Таким образом мы незаметно построили целую монадическую систему
ввода/вывода для хаскеля.
</p>
</div>
</div>
<div id="outline-container-sec-1-8-2" class="outline-4">
<h4 id="sec-1-8-2"><span class="section-number-4">1.8.2</span> <span class="done DONE">DONE</span> Introduce IO Monad</h4>
<div class="outline-text-4" id="text-1-8-2">
<p>
То, что дальше, не то, как есть на самом деле, но хорошо в целях обучения.
</p>
<div class="org-src-container">

<pre class="src src-haskell">main :: ReadWorld &rarr; ((), RealWorld)
</pre>
</div>
<p>
<code>RealWorld</code> - фейковый тип, который используется вместо <code>Int</code> из
предудыщих примеров. Собстенно вот как выглядит сам <code>IO</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">type IO a = RealWorld &rarr; (a, RealWorld)
</pre>
</div>
<p>
Таким образом видно, что у <code>main</code> тип <code>IO ()</code>, у <code>getchar</code> тип
<code>IO Char</code> и т.д. Можно считать, что тип <code>IO Char</code> означает "взять
текущий <code>RealWorld</code>, сделать с ним что-то и вернуть <code>Char</code> и возможно
измененный <code>RealWorld</code>".
</p>
<div class="org-src-container">

<pre class="src src-haskell">getChar :: RealWorld &rarr; (Char, RealWorld)

main :: RealWorld &rarr; ((), RealWorld)
main world0 = let (a, world1) = getChar world0
                  (b, world2) = getChar world1
              in  ((), world2)
</pre>
</div>
<p>
Есть 3 нюанса:
</p>
<ol class="org-ol">
<li>Мы не можем опустить ни один из вызовов <code>getChar</code>.
</li>
<li>Мы не можем поменять вызовы <code>getChar</code> местами.
</li>
<li>В теории мы можем дублировать вызовы <code>getChar</code>, но на самом деле
</li>
</ol>
<p>
компиляторы никогда не дублируют вызовы в таких простых случая, иначе
не будет никаких гарантий по скорости работы.
</p>

<p>
Теперь о том, как на самом деле реализован <code>IO</code>.
</p>
<div class="org-src-container">

<pre class="src src-haskell">newtype IO a = IO (State# RealWorld &rarr; (# State# RealWorld, a #))

{-# LANGUAGE MagicHash #-} -- allows using # in names

data Mystery# a = Magic# a deriving (Show)

Magic# 3 -- Magic# 3
Magic# 3 :: Num a &rArr; Mystery# a
</pre>
</div>
<p>
Нафиг надо? Просто соглашение, чтобы разделять boxed и unboxed типы.
</p>
<div class="org-src-container">

<pre class="src src-haskell">{-# LANGUAGE UnboxedTuples #-}

duplicatedToUnbox :: a &rarr; (# a, a #)
duplicatedToUnbox x = (# x, x #)
</pre>
</div>
<p>
В отличие от обычных, boxed кортежей, unboxed кортежи не требуют
дополнительной памяти и не создают thunks. Тип является unboxed, если
его представление не является указателем. Теперь вернемся к <code>State#</code>
и <code>RealWorld</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">newtype IO a = IO (State# RealWorld &rarr; (# State# RealWorld, a #))

data State# s
{-
State# - примитив, unlifted. У него есть один параметрический тип.
Единственная цель этого параметра поддерживать различными состояния
потоков. По сути ничем не представлен.
-}

data RealWorld
{-
RealWorld - полностью магия. Это примитив, unlifted. Мы никогда не
работаем со значениями типа RealWorld, этот тип используется только
в системе типов, для параметризации State#.
-}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-3" class="outline-4">
<h4 id="sec-1-8-3"><span class="section-number-4">1.8.3</span> <span class="done DONE">DONE</span> <code>[3/3]</code> do notation</h4>
<div class="outline-text-4" id="text-1-8-3">
</div>
<ol class="org-ol"><li><a id="sec-1-8-3-1" name="sec-1-8-3-1"></a><span class="done DONE">DONE</span> Syntax sugar<br  /><div class="outline-text-5" id="text-1-8-3-1">
<div class="org-src-container">

<pre class="src src-haskell">(&gt;&gt;) :: IO a &rarr; IO b &rarr; IO b
(action1 &gt;&gt; action2) world0 =
    let (_, world1) = action1 world0
        (b, world2) = action2 world1
    in  (b, world2)

putStrLn :: String &rarr; IO ()

main = do putStrLn "Hello!"
main = putStrLn "Hello!"

main = do putStrLn "What is your name?"
          putStrLn "How old are you?"
          putStrLn "Nice day!"

main = (putStrLn "What is your name?") &gt;&gt;
       (putStrLn "How old are you?") &gt;&gt;
       (putStrLn "Nice day!")

(&gt;&gt;=) :: IO a &rarr; (a &rarr; IO b) &rarr; IO b
(&gt;&gt;=) :: IO a &rarr; (a &rarr; RealWorld &rarr; (b, RealWorld)) &rarr; IO b

(action1 &gt;&gt;= action2) world0 =
    let (a, world1) = action1 world0
        (b, world2) = action2 a world1
    in  (b, world2)

getLine :: IO String

main = do s &larr; getLine
          putStrLn s

main = getLine
       &gt;&gt;= \s &rarr; putStrLn s

main = getLine &gt;&gt;= putStrLn
</pre>
</div>
<p>
<code>GHCi</code> - бесконечный <code>do</code>-блок внутри <code>IO</code>.
</p>
<div class="org-src-container">

<pre class="src src-haskell">return :: a &rarr; IO a
return a world0 = (a, world0)

getReversedLine :: IO String
getReversedLine = do
    s &larr; getLine
    return $ reverse s

main :: IO ()
main = do
    rs &larr; getReversedLine
    putStrLn rs

main :: IO ()
main = do
    s &larr; getLine
    let rs = reverse s
    putStrLn $ "Reversed input : " ++ rs

main :: IO ()
main =     getLine
       &gt;&gt;= \s &rarr; let rs = reverse s in
           putStrLn $ "Reversed input : " ++ rs

-- DO NOT DO THE FOLLOWING
let s = getLine -- Doesn't read from console to 's'
rs &larr; reverse s -- 'reverse s' is not a monadic action inside IO
</pre>
</div>
</div>
</li>
<li><a id="sec-1-8-3-2" name="sec-1-8-3-2"></a><span class="done DONE">DONE</span> Applicative Do<br  /><div class="outline-text-5" id="text-1-8-3-2">
<p>
Начиная с <code>GHC 8</code> появилась такая штука. Если возможно, компилятор
может сделать desugar <code>do</code> для аппликатива:
</p>
<div class="org-src-container">

<pre class="src src-haskell">{-# LANGUAGE ApplicativeDo #-}

appPair :: Applicative f &rArr; f a &rarr; f b &rarr; f (a, b)
appPair a b = do
    x &larr; a
    y &larr; b
    pure (x, y)

-- Translates to
(\x y &rarr; (x, y)) &lt;$&gt; a &lt;*&gt; b

appPair (Just 3) (Just 4) -- Just (3, 4)
</pre>
</div>
<p>
Нафиг надо? Есть 2 причины:
</p>
<ol class="org-ol">
<li>Синтаксис для аппликативов может быть немного странным и сложным
</li>
</ol>
<p>
в написании. Синтаксис с <code>do</code> выглядит более естественным. Для сравнения:
</p>
<div class="org-src-container">

<pre class="src src-haskell">(\x y z &rarr; x*y + y*z + z*x) &lt;$&gt; expr1 &lt;*&gt; expr2 &lt;*&gt; expr3

do x &larr; expr1; y &larr; expr2; z &larr; expr3; return (x*y + y*z + z*x)
</pre>
</div>
<ol class="org-ol">
<li>Иногда аппликативный <code>bind</code> может быть более эффективным, чем
</li>
</ol>
<p>
монадический, и иногда это действительно важно.
</p>

<p>
Иногда кстати требуется ограничение <code>Monad</code>. А теперь веселый пример:
</p>
<div class="org-src-container">

<pre class="src src-haskell">do
    x1 &larr; a
    x2 &larr; b
    x3 &larr; c x1
    x4 &larr; d
    return (x2, x3, x4)

-- Translates to
(\(x2, x3) x4 &rarr; (x2, x3, x4)
    &lt;$&gt; join ((\x1 x2 &rarr; do
                            x3 &larr; c x1
                            return (x2, x3))
               &lt;$&gt; a
               &lt;*&gt; b)
    &lt;*&gt; d)
</pre>
</div>
</div>
</li>
<li><a id="sec-1-8-3-3" name="sec-1-8-3-3"></a><span class="done DONE">DONE</span> RebindableSyntax<br  /><div class="outline-text-5" id="text-1-8-3-3">
<p>
Можно перегрузить <code>do</code>-нотацию и другие вещи:
</p>
<div class="org-src-container">

<pre class="src src-haskell">{-# LANGUAGE RebindableSyntax #-}

import Prelude hiding ((&gt;&gt;=))
import qualified Control.Monad

(&gt;&gt;=) :: IO a &rarr; (a &rarr; IO b) &rarr; IO b
m &gt;&gt;= f = putStrLn "Called my bind!" &gt;&gt; m Control.Monad.&gt;&gt;= f

myReadLine :: IO String
myReadLine = do
    putStrLn "Before getLine"
    s &larr; getLine
    putStrLn "After getLine"
    return s

{-
ghci&gt; myReadLine
Before getLine
Called my bind!
Hello!
After getLine
"Hello!"
-}
</pre>
</div>
<p>
Еще эта штука работает и с <code>ApplicativeDo</code>. Еще пример:
</p>
<div class="org-src-container">

<pre class="src src-haskell">{-# LANGUAGE RebindableSyntax #-}

import Prelude

addNumbers = do
    80
    60
    10
    where (&gt;&gt;) = (+)

addNumbers -- 150
</pre>
</div>
<p>
Нафиг надо? Мы можем реализовывать всякие классные штуки (например,
мьютексы, безопасные по типам), используя не только стандартные монады:
<code>Effect monads</code>, <code>Indexed monads</code>, <code>Constraint monads</code>, <code>Supermonads</code>. Пример:
</p>
<div class="org-src-container">

<pre class="src src-haskell">class EffectMonad m where
    return :: a &rarr; m e a
    (&gt;&gt;=) :: m i a &rarr; (a &rarr; m j b) &rarr; m (i &lt;&gt; j) b
</pre>
</div>
</div>
</li></ol>
</div>
<div id="outline-container-sec-1-8-4" class="outline-4">
<h4 id="sec-1-8-4"><span class="section-number-4">1.8.4</span> <span class="done DONE">DONE</span> Mutable data: IORef and IOArray</h4>
<div class="outline-text-4" id="text-1-8-4">
<p>
В хаскеле все неизменяемое. Но что если хотим сделать что-то такое:
</p>
<div class="org-src-container">

<pre class="src src-haskell">main = do
    let a0 = readVariable varA
    let _  = writeVariable varA 1
    let a1 = readVariable varA
    print (a0, a1)
</pre>
</div>
<p>
В этом случае куча проблем:
</p>
<ol class="org-ol">
<li>Компилятор видит 2 вызова <code>readVariable</code> с одним параметром,
</li>
</ol>
<p>
так что он просто возьмет значение из первого вызова.
</p>
<ol class="org-ol">
<li>Результат <code>writeVariable</code> не используется, так что компилятор
</li>
</ol>
<p>
просто выкинет этот вызов.
</p>
<ol class="org-ol">
<li>Эти 3 вызова могут быть переставлены.
</li>
</ol>

<p>
Решить можно, если бахнем все это в <code>IO</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">import Data.IORef

main = do varA &larr; newIORef 0 -- Create and initialize a new variable
          a0 &larr; readIORef varA
          writeIORef varA 1
          a1 &larr; readIORef varA
          print (a0, a1)
</pre>
</div>
<p>
Здесь <code>varA</code> имеет тип <code>IORef Int</code>, что означает, что переменная (ссылка)
внутри монады <code>IO</code> хранит значение типа <code>Int</code>. <code>newIORef</code> создает
новую переменную (ссылку) и возвращает его, а потом действия используют
эту ссылку. Значение, возвращаемое <code>readIORef varA</code> зависит не только от
переменной, но и от момента, в который выполняется данная операция.
</p>

<p>
Такие же штуки есть для массивов, хэш-таблиц и других изменяемых
структур данных. Вот пример:
</p>
<div class="org-src-container">

<pre class="src src-haskell">import Data.Array.IO

main = do arr &larr; newArray (1, 10) 37 :: IO (IOArray Int Int)
          a &larr; readArray arr 1
          writeArray arr 1 64
          b &larr; readArray arr 1
          print (a, b)

-- (37, 64)
</pre>
</div>
<p>
Тут сначала создается массив из 10 элементов со значением 37. Дальше
все понятно вроде.
</p>

<p>
Другие штуки, которые зависят от состояния, часто тоже реализованы
с помощью <code>IO</code>. Например, генератор случайных чисел:
</p>
<div class="org-src-container">

<pre class="src src-haskell">rand :: IO Int

foreign import ccall
    sin :: Double &rarr; Double -- OK, чистая функция

foreign import ccall
    tell :: Int &rarr; IO Int -- Нужно IO, так как результат бывает разным
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-5" class="outline-4">
<h4 id="sec-1-8-5"><span class="section-number-4">1.8.5</span> <span class="done DONE">DONE</span> sequence_</h4>
<div class="outline-text-4" id="text-1-8-5">
<p>
Например, хотим запихнуть несколько <code>IO</code> действий в список:
</p>
<div class="org-src-container">

<pre class="src src-haskell">ioActions :: [IO ()]
ioActions = [(print "Hello!"),
             (putStr "just kidding"),
             (getChar &gt;&gt; return ())
            ]

main = do head ioActions
          ioActions !! 1
          last ioActions
</pre>
</div>
<p>
Но это выглядит не очень, поэтому можно сделать так:
</p>
<div class="org-src-container">

<pre class="src src-haskell">sequence_ :: [IO a] &rarr; IO ()

main = sequence_ ioActions

sequence_ :: [IO a] &rarr; IO ()
sequence_ []     = return ()
sequence_ (x:xs) = do x
                      sequence_ xs
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-6" class="outline-4">
<h4 id="sec-1-8-6"><span class="section-number-4">1.8.6</span> <span class="done DONE">DONE</span> Exceptions (catch, throwIO, custom exceptions, bracket, etc.)</h4>
<div class="outline-text-4" id="text-1-8-6">
<p>
Как делать <code>throw</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">throwIO :: Exception e &rArr; e &rarr; IO a

import Control.Exception (ArithException (..), catch, throwIO)
import Control.Monad (when)

readAndDivide :: IO Int
readAndDivide = do
    x &larr; readLn
    y &larr; readLn
    when (y == 0) $ throwIO DivideByZero
    return $ x `div` y

{-
ghci&gt; readAndDivide
7
3
2

ghci&gt; readAndDivide
3
0
"*** Exception: divide by zero"
-}
</pre>
</div>
<p>
Как делать <code>catch</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">catch :: Exception e &rArr; IO a &rarr; (e &rarr; IO a) &rarr; IO a

safeReadAndDivide :: IO Int
safeReadAndDivide = readAndDivide `catch` \DivideByZero &rarr; return (-1)

{-
ghci&gt; safeReadAndDivide
7
3
2

ghci&gt; safeReadAndDivide
3
0
-1
-}
</pre>
</div>
<p>
Пара нюансов про исключения:
</p>
<ol class="org-ol">
<li><code>IO</code> может бросать любые исключения
</li>
<li>Не представлены в системе типов (но об этом позже)
</li>
</ol>

<p>
Как делать свои исключения:
</p>
<div class="org-src-container">

<pre class="src src-haskell">{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveDataTypeable #-}

import Control.Exception (Exception)
import Data.Typeable (Typeable)

data MyException = DummyException
    deriving (Show, Typeable, Exception)

{-
ghci&gt; throwIO DummyException
"***" Exception: DummyException
-}

{-
ghci&gt; :{
ghci| throwIO DummyException `catch` \DummyException &rarr;
ghci|     putStrLn "Dummy exception is thrown"
ghci| :}
Dummy exception is thrown
-}
</pre>
</div>
<p>
Теперь про <code>try</code>, <code>finally</code> и <code>bracket</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">try :: Exception e &rArr; IO a &rarr; IO (Either e a)
tryJust :: Exception e &rArr; (e &rarr; Maybe b) &rarr; IO a &rarr; IO (Either b a)

finally :: IO a -- computation to run first
        &rarr;  IO b -- computation to run afterward (even if an exception was raised)
        &rarr;  IO a

-- | Like 'finally', but only performs the final action
-- if there was an exception raised by the computation.
onException :: IO a &rarr; IO b &rarr; IO a

bracket :: IO a       -- computation to run first ("acquire resource")
        &rarr;  (a &rarr; IO b) -- computation to run last ("release resource")
        &rarr;  (a &rarr; IO c) -- computation to run in-between
        &rarr;  IO c       -- returns the value from the in-between computation
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-8-7" class="outline-4">
<h4 id="sec-1-8-7"><span class="section-number-4">1.8.7</span> <span class="done DONE">DONE</span> unsafePerformIO and unsafeInterleaveIO</h4>
<div class="outline-text-4" id="text-1-8-7">
<p>
Эти штуки используются, если мы хотим использовать <code>IO</code> внутри чистых
функций. Реализовано примерно так:
</p>
<div class="org-src-container">

<pre class="src src-haskell">unsafePerformIO action = let (a, world1) = action createNewWorld
                         in (world1 `seq` a)
</pre>
</div>
<p>
Примеры:
</p>
<div class="org-src-container">

<pre class="src src-haskell">import System.IO.Unsafe

foo :: ()
foo = unsafePerformIO $ putStrLn "foo"

bar :: String
bar = unsafePerformIO $ do putStrLn "bar"
                           return "baz"

main = do let f = foo
          putStrLn bar

helper i = print i &gt;&gt; return i

main = do
    one &larr; helper 1
    two &larr; helper 2
    print $ one + two

main = do
    one &larr; helper 1
    let two = unsafePerformIO $ helper 2
    print $ one + two
</pre>
</div>
<p>
Возможно 2 результата:
</p>
<ol class="org-ol">
<li>Очевидный
<ol class="org-ol">
<li>Запустится <code>helper 1</code>
</li>
<li>Создастся thunk для запуска <code>helper 2</code>
</li>
<li>Вычислится <code>one + two</code>, вынудив thunk <code>helper 2</code> вычислиться
</li>
<li>Вывод результата <code>one + two</code>
</li>
</ol>
</li>
<li>С перестановкой вызовов
<ol class="org-ol">
<li>Создастся и вычислится thunk <code>helper 2</code>
</li>
<li>Запустится <code>helper 1</code>
</li>
<li>Вывод результата <code>one + two</code>
</li>
</ol>
</li>
</ol>

<p>
Теперь про <code>unsafeInterleaveIO</code>.
</p>
<div class="org-src-container">

<pre class="src src-haskell">import System.IO.Unsafe

helper i = print i &gt;&gt; return i

main = do
    one &larr; helper 1
    two &larr; unsafeInterleaveIO $ helper 2
    print $ one + two
</pre>
</div>
<p>
Как это примерно выглядит:
</p>
<div class="org-src-container">

<pre class="src src-haskell">do
    before
    unsafeInterleaveIO side
    after
</pre>
</div>
<p>
Какое-то дерьмо из презентации, не хочу разбираться.
</p>
</div>
</div>
<div id="outline-container-sec-1-8-8" class="outline-4">
<h4 id="sec-1-8-8"><span class="section-number-4">1.8.8</span> <span class="done DONE">DONE</span> Efficient String representations: Text, ByteString</h4>
<div class="outline-text-4" id="text-1-8-8">
<p>
Можно использовать перегруженные строки:
</p>
<div class="org-src-container">

<pre class="src src-haskell">type String = [Char]

{-# LANGUAGE OverloadedStrings #-}

class IsString a where
    fromString :: String &rarr; a
"foo" :: IsString a &rArr; a
</pre>
</div>
<p>
Посмтрим на <code>Text</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">{-# LANGUAGE OverloadedStrings #-}

import qualified Data.Text as T

-- From pack
myTStr1 :: T.Text
myTStr1 = T.pack ("foo" :: String)

-- From overloaded string literal
myTStr2 :: T.Text
myTStr2 = "bar"
</pre>
</div>
<p>
Теперь <code>ByteString</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">{-# LANGUAGE OverloadedStrings #-}

import qualified Data.ByteString       as S
import qualified Data.ByteString.Char8 as S8

-- From pack
bstr1 :: S.ByteString
bstr1 = S.pack ("foo" :: String)

-- From overloaded string literal
bstr2 :: S8.ByteString
bstr2 = "bar"
</pre>
</div>
<p>
Что когда использовать:
</p>
<ol class="org-ol">
<li>Бинарные данные:
<ol class="org-ol">
<li>Ленивые запакованные данные - <code>Data.ByteString.Lazy</code>
</li>
<li>Строгие запакованные данные - <code>Data.ByteString</code>
</li>
</ol>
</li>
<li>Текст:
<ol class="org-ol">
<li>ASCII или 8-битные:
<ol class="org-ol">
<li>Запакованные ленивые - <code>Data.ByteString.Lazy.Char8</code>
</li>
<li>Запакованные строгие - <code>Data.ByteString.Char8</code>, <code>Data.CompactString.ASCII</code> или <code>Data.CompactString</code> with <code>Latin1</code>
</li>
</ol>
</li>
<li>Unicode
<ol class="org-ol">
<li>UTF-32:
<ol class="org-ol">
<li>Незапакованные ленивые - <code>[Char]</code>
</li>
</ol>
</li>
<li>UTF-16:
<ol class="org-ol">
<li>Запакованные ленивые - <code>Data.Text.Lazy</code>
</li>
<li>Запакованные строгие - <code>Data.Text</code> или <code>Data.CompactString.UTF-16</code>
</li>
</ol>
</li>
<li>UTF-8:
<ol class="org-ol">
<li>Незапакованные и ленивые - <code>Codec.Binary.UTF8.Generic</code>
</li>
<li>Запакованные и ленивые - <code>Data.ByteString.Lazy.UTF8</code>
</li>
<li>Запакованные и строгие - <code>Data.CompactString.UTF8</code> или <code>Data.ByteString.UTF8</code>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> <span class="done DONE">DONE</span> <code>[7/7]</code> Lecture 9: Monad Transformers</h3>
<div class="outline-text-3" id="text-1-9">
</div>
<div id="outline-container-sec-1-9-1" class="outline-4">
<h4 id="sec-1-9-1"><span class="section-number-4">1.9.1</span> <span class="done DONE">DONE</span> Композиция монад</h4>
<div class="outline-text-4" id="text-1-9-1">
<p>
Хотим композицию <code>Reader</code> и <code>State</code>, например, но:
</p>
<ol class="org-ol">
<li>У <code>Reader</code> нет <code>put</code>
</li>
<li>У <code>State</code> нет <code>ask</code>
</li>
</ol>

<p>
Пути решения:
</p>
<ol class="org-ol">
<li><code>RWS</code> - есть лишний <code>Writer</code>
</li>
<li>Использовать только <code>State</code> - недостаточно ограничений на типы
</li>
</ol>

<p>
На помощь приходят трансформеры монад:
</p>
<div class="org-src-container">

<pre class="src src-haskell">foo :: ReaderT Int (State [Int]) Int -- or StateT [Int] (Reader Int) Int
foo i = do
    baseCounter &larr; ask
    let newCounter = baseCounter + i
    put [baseCounter, newCounter]
    return newCounter
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-9-2" class="outline-4">
<h4 id="sec-1-9-2"><span class="section-number-4">1.9.2</span> <span class="done DONE">DONE</span> Пример с MaybeIO</h4>
<div class="outline-text-4" id="text-1-9-2">
<p>
Сначала было так:
</p>
<div class="org-src-container">

<pre class="src src-haskell">do
    mc1 &larr; tryConnect "host1"
    case mc1 of
        Nothing &rarr; return Nothing
        Just c1 &rarr; do
            mc2 &larr; tryConnect "host2"
            case mc2 of
                Nothing &rarr; return Nothing
                Just c2 &rarr; do
                    ...
</pre>
</div>
<p>
Теперь попробуем скомбинировать <code>Maybe</code> и <code>IO</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">newtype MaybeIO a = MaybeIO { runMaybeIO :: IO (Maybe a) }

instance Monad MaybeIO where
    return x = MaybeIO (return (Just x))
    MaybeIO action &gt;&gt;= f = MaybeIO $ do
        retult &larr; action
        case result of
            Nothing &rarr; return Nothing
            Just x &rarr; runMaybeIO (f x)

result &larr; runMaybeIO $ do
    c1 &larr; MaybeIO $ tryConnect "host1"
    c2 &larr; MaybeIO $ tryConnect "host2"
    ...
</pre>
</div>
<p>
Имеем право захотеть вот такое:
</p>
<div class="org-src-container">

<pre class="src src-haskell">result &larr; runMaybeIO $ do
    c1 &larr; MaybeIO $ tryConnect "host1"
    print "Hello"
    c2 &larr; MaybeIO $ tryConnect "host2"
</pre>
</div>
<p>
Трансформируем <code>IO</code> в <code>MaybeIO</code>:
</p>
<div class="org-src-container">

<pre class="src src-haskell">transformIO2MaybeIO :: IO a &rarr; MaybeIO a
transformIO2MaybeIO action = MaybeIO $ do
    result &larr; action
    return (Just result)

result &larr; runMaybeIO $ do
    c1 &larr; MaybeIO $ tryConnect "host1"
    transformIO2MaybeIO $ print "Hello"
    c2 &larr; MaybeIO $ tryConnect "host2"
    ...
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-9-3" class="outline-4">
<h4 id="sec-1-9-3"><span class="section-number-4">1.9.3</span> <span class="done DONE">DONE</span> MaybeT transformer</h4>
<div class="outline-text-4" id="text-1-9-3">
<p>
Дженеричная версия <code>MaybeIO</code> по сути:
</p>
<div class="org-src-container">

<pre class="src src-haskell">newtype MaybeT m a = { runMaybeT :: m (Maybe a) }

instance Monad m &rArr; Monad (MaybeT m) where
    return x = MaybeT (return (Just x))
    MaybeT action &gt;&gt;= f = MaybeT $ do
        result &larr; action
        case result of
            Nothing &rarr; return Nothing
            Just x &rarr; runMaybeT (f x)

transformToMaybeT :: Monad m &rArr; m a &rarr; MaybeT m a
transformToMaybeT action = MaybeT $ do
    result &larr; action
    return (Just result)

class MonadTrans t where -- t :: (* &rarr; *) &rarr; * &rarr; *
    lift :: Monad m &rArr; m a &rarr; t m a

instance MonadTrans MaybeT where
    lift = transformToMaybeT

emailIsValid :: String &rarr; Bool
emailIsValid email = '@' `elem` email

askEmail :: MaybeT IO String
askEmail = do
    lift $ putStrLn "Input your email, please:"
    email &larr; lift getLine
    guard $ emailIsValid email
    return email

main :: IO ()
main = do
    email &larr; runMaybeT askEmail
    case email of
        Nothing &rarr; putStrLn "Wrong email."
        Just email' &rarr; putStrLn $ "OK, your email is " ++ email'
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-9-4" class="outline-4">
<h4 id="sec-1-9-4"><span class="section-number-4">1.9.4</span> <span class="done DONE">DONE</span> ReaderT transformer</h4>
<div class="outline-text-4" id="text-1-9-4">
<p>
Мотивирующий кейс:
</p>
<div class="org-src-container">

<pre class="src src-haskell">gitRoot = "/.git/"

getPathToBranches :: Text &rarr; Text
getPathToBranches pathToRepo = "Branches: " &lt;&gt; pathToRepo &lt;&gt; gitRoot &lt;&gt; "branches"

getPathToHooks :: Text &rarr; Text
getPathToHooks pathToRepo = "Hooks: " &lt;&gt; pathToRepo &lt;&gt; gitRoot &lt;&gt; "hooks"

showRepoInternalDirectories :: Text &rarr; Text
showRepoInternalDirectories pathToRepo = let pathToBranches = getPathToBranches pathToRepo
                                             pathToHooks    = getPathToHooks pathToRepo
                                         in unlines [pathToBranches, pathToRepos]

main :: IO ()
main = do
    pathToRepo &larr; readFile "my.conf"
    let cleanPath = strip pathToRepo
    let finalInfo = showRepoInternalDirectories cleanPath
    putStrLn finalInfo
</pre>
</div>
<p>
Теперь с трансформером:
</p>
<div class="org-src-container">

<pre class="src src-haskell">newtype ReaderT r m a = ReaderT { runReaderT :: r &rarr; m a }
type RepoPath = Text
type PathReader = ReaderT RepoPath IO RepoPath

getPathToBranches :: PathReader
getPathToBranches = do
    pathToRepo &larr; ask
    return $ "Branches: " &lt;&gt; pathToRepo &lt;&gt; gitRoot &lt;&gt; "branches"

showRepoInternalDirectories :: PathReader
showRepoInternalDirectories = do
    pathToBranches &larr; getPathToBranches
    pathToHooks &larr; getPathToHooks
    return $ unlines [pathToBranches, pathToHooks]

main :: IO ()
main = do
    pathToRepo &larr; readFile "my.conf"
    let cleanPath = strip pathToRepo
    finalInfo &larr; runReaderT showRepoInternalDirectories cleanPath
    putStrLn finalInfo
</pre>
</div>
<p>
Сам трансформер:
</p>
<div class="org-src-container">

<pre class="src src-haskell">newtype ReaderT r m a = ReaderT { runReaderT :: r &rarr; m a }

type Reader r a = ReaderT r Identity a

instance (Monad m) &rArr; Monad (ReaderT r m) where
    return = lift . return
    m &gt;&gt;= f = ReaderT $ \r &rarr; do
        a &larr; runReaderT m r
        runReaderT (f a) r

instance MonadTrans ReaderT where
    lift m = ReaderT (const m) -- left ma = ReaderT $ \r &rarr; ma
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-9-5" class="outline-4">
<h4 id="sec-1-9-5"><span class="section-number-4">1.9.5</span> <span class="done DONE">DONE</span> StateT transformer</h4>
<div class="outline-text-4" id="text-1-9-5">
<div class="org-src-container">

<pre class="src src-haskell">newtype StateT s m a = StateT { runStateT :: (s &rarr; m (a, s)) }

instance (Monad m) &rArr; Monad (StateT s m) where
    return a = StateT $ \s &rarr; return (a, s)
    (StateT x) &gt;&gt;= f = StateT $ \s &rarr; do
        (v, s') &larr; x s -- get new value and state
        runStateT (f v) s' -- pass them to f

instance MonadTrans StateT where
    lift m = StateT $ \s &rarr; m &gt;&gt;= (\x &rarr; return (x, s))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-9-6" class="outline-4">
<h4 id="sec-1-9-6"><span class="section-number-4">1.9.6</span> <span class="done DONE">DONE</span> Таблица трансформеров</h4>
<div class="outline-text-4" id="text-1-9-6">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Base monad</th>
<th scope="col" class="left">Transformer</th>
<th scope="col" class="left">Original type</th>
<th scope="col" class="left">Combined type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Maybe</td>
<td class="left">MaybeT</td>
<td class="left">Maybe a</td>
<td class="left">m (Maybe a)</td>
</tr>

<tr>
<td class="left">Either</td>
<td class="left">EitherT</td>
<td class="left">Either a b</td>
<td class="left">m (Either a b)</td>
</tr>

<tr>
<td class="left">Writer</td>
<td class="left">WriterT</td>
<td class="left">(a, w)</td>
<td class="left">m (a, w)</td>
</tr>

<tr>
<td class="left">Reader</td>
<td class="left">ReaderT</td>
<td class="left">r &rarr; a</td>
<td class="left">r &rarr; m a</td>
</tr>

<tr>
<td class="left">State</td>
<td class="left">StateT</td>
<td class="left">s &rarr; (a, s)</td>
<td class="left">s &rarr; m (a, s)</td>
</tr>

<tr>
<td class="left">Cont</td>
<td class="left">ContT</td>
<td class="left">(a &rarr; r) &rarr; r</td>
<td class="left">(a &rarr; m r) &rarr; m r</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-1-9-7" class="outline-4">
<h4 id="sec-1-9-7"><span class="section-number-4">1.9.7</span> <span class="done DONE">DONE</span> Mtl style of transformation</h4>
<div class="outline-text-4" id="text-1-9-7">
<div class="org-src-container">

<pre class="src src-haskell">class Monad m &rArr; MonadReader r m | m &rarr; r where
    ask :: m r
    local :: (r &rarr; r) &rarr; m a &rarr; m a
    reader :: (r &rarr; a) &rarr; m a

-- good old simple implementation of all functions for Reader
instance Monad m &rArr; MonadReader r (ReaderT r m) where
    ...

instance MonadReader r m &rArr; MonadReader r (StateT s m) where
    ask = lift ask
    local = mapStateT . local
    reader = lift . reader

class (Monad m) &rArr; MonadIO m where
    liftIO :: IO a &rarr; m a

instance MonadIO IO where
    liftIO = id

instance MonadIO m &rArr; MonadIO (StateT s m) where
    liftIO = lift . liftIO

instance MonadIO m &rArr; MonadIO (ReaderT r m) where
    liftIO = lift . liftIO
</pre>
</div>
<p>
Безболезненная конвертация в mtl:
</p>
<div class="org-src-container">

<pre class="src src-haskell">-- Complx type for which we need to write all instances manually :(

newtype M a = M (Environment &rarr; MyState &rarr; IO (a, MyState))
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses #-}

-- Move all dirty work to compiler

newtype M a = M (ReaderT Environment (StateT MyState IO) a)
    deriving (Functor, Applicative, Monad, MonadIO
        , MonadState MyState, MonadReader Environment)
</pre>
</div>
<p>
Попробуем поработать с исключениями:
</p>
<div class="org-src-container">

<pre class="src src-haskell">class Monad m &rArr; MonadThrow m where
    throwM :: Exception e &rArr; e &rarr; m a

instance MonadThrow Maybe where
    throwM _ = Nothing

instance MonadThrow IO where
    throwM = Control.Exception.throwIO

instance MonadThrow m &rArr; MonadThrow (StateT s m) where
    throwM = lift . throwM

class MonadThrow m &rArr; MonadCatch m where
    catch :: Exception e &rArr; m a &rarr; (e &rarr; m a) &rarr; m a

instance MonadCatch IO where
    catch = Control.Exception.catch
</pre>
</div>
<p>
Нафиг нужен mtl? Просто в таком стиле есть дофига определенных
<code>Monad*</code> и это может быть удобно.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3">1.10</span> <span class="todo TODO">TODO</span> <code>[0/12]</code> Lecture 10: Speeding up haskell</h3>
<div class="outline-text-3" id="text-1-10">
</div><div id="outline-container-sec-1-10-1" class="outline-4">
<h4 id="sec-1-10-1"><span class="section-number-4">1.10.1</span> <span class="todo TODO">TODO</span> List concatenation pitfalls and Difference List</h4>
</div>
<div id="outline-container-sec-1-10-2" class="outline-4">
<h4 id="sec-1-10-2"><span class="section-number-4">1.10.2</span> <span class="todo TODO">TODO</span> foldr vs foldl vs foldl'_</h4>
</div>
<div id="outline-container-sec-1-10-3" class="outline-4">
<h4 id="sec-1-10-3"><span class="section-number-4">1.10.3</span> <span class="todo TODO">TODO</span> WHNF (weak head normal form)</h4>
</div>
<div id="outline-container-sec-1-10-4" class="outline-4">
<h4 id="sec-1-10-4"><span class="section-number-4">1.10.4</span> <span class="todo TODO">TODO</span> seq, deepseq, NFData</h4>
</div>
<div id="outline-container-sec-1-10-5" class="outline-4">
<h4 id="sec-1-10-5"><span class="section-number-4">1.10.5</span> <span class="todo TODO">TODO</span> Irrefutable patterns</h4>
</div>
<div id="outline-container-sec-1-10-6" class="outline-4">
<h4 id="sec-1-10-6"><span class="section-number-4">1.10.6</span> <span class="todo TODO">TODO</span> BangPatterns</h4>
</div>
<div id="outline-container-sec-1-10-7" class="outline-4">
<h4 id="sec-1-10-7"><span class="section-number-4">1.10.7</span> <span class="todo TODO">TODO</span> Strict Haskell</h4>
</div>
<div id="outline-container-sec-1-10-8" class="outline-4">
<h4 id="sec-1-10-8"><span class="section-number-4">1.10.8</span> <span class="todo TODO">TODO</span> Space leaks</h4>
</div>
<div id="outline-container-sec-1-10-9" class="outline-4">
<h4 id="sec-1-10-9"><span class="section-number-4">1.10.9</span> <span class="todo TODO">TODO</span> Deforestation</h4>
</div>
<div id="outline-container-sec-1-10-10" class="outline-4">
<h4 id="sec-1-10-10"><span class="section-number-4">1.10.10</span> <span class="todo TODO">TODO</span> Streal Fusion</h4>
</div>
<div id="outline-container-sec-1-10-11" class="outline-4">
<h4 id="sec-1-10-11"><span class="section-number-4">1.10.11</span> <span class="todo TODO">TODO</span> ST monad (STRef, STArray)</h4>
</div>
<div id="outline-container-sec-1-10-12" class="outline-4">
<h4 id="sec-1-10-12"><span class="section-number-4">1.10.12</span> <span class="todo TODO">TODO</span> Criterion</h4>
</div>
</div>
<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11"><span class="section-number-3">1.11</span> <span class="todo TODO">TODO</span> <code>[0/3]</code> Lecture 11: Template Haskell and Lens</h3>
<div class="outline-text-3" id="text-1-11">
</div><div id="outline-container-sec-1-11-1" class="outline-4">
<h4 id="sec-1-11-1"><span class="section-number-4">1.11.1</span> <span class="todo TODO">TODO</span> <code>[0/2]</code> Template Haskell</h4>
<div class="outline-text-4" id="text-1-11-1">
</div><ol class="org-ol"><li><a id="sec-1-11-1-1" name="sec-1-11-1-1"></a><span class="todo TODO">TODO</span> boilerplating tuple code<br  /></li>
<li><a id="sec-1-11-1-2" name="sec-1-11-1-2"></a><span class="todo TODO">TODO</span> Generate Automatic Instances<br  /></li></ol>
</div>
<div id="outline-container-sec-1-11-2" class="outline-4">
<h4 id="sec-1-11-2"><span class="section-number-4">1.11.2</span> <span class="todo TODO">TODO</span> <code>[0/3]</code> Lens</h4>
<div class="outline-text-4" id="text-1-11-2">
</div><ol class="org-ol"><li><a id="sec-1-11-2-1" name="sec-1-11-2-1"></a><span class="todo TODO">TODO</span> Creating our simple lens<br  /></li>
<li><a id="sec-1-11-2-2" name="sec-1-11-2-2"></a><span class="todo TODO">TODO</span> Introducing real Lens'<br  /></li>
<li><a id="sec-1-11-2-3" name="sec-1-11-2-3"></a><span class="todo TODO">TODO</span> Nice example with real lens (view, traversed, filtered, zoom)<br  /></li></ol>
</div>
<div id="outline-container-sec-1-11-3" class="outline-4">
<h4 id="sec-1-11-3"><span class="section-number-4">1.11.3</span> <span class="todo TODO">TODO</span> Prism</h4>
</div>
</div>
<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12"><span class="section-number-3">1.12</span> <span class="todo TODO">TODO</span> <code>[0/9]</code> Lecture 12: Parallel and Concurrent Haskell</h3>
<div class="outline-text-3" id="text-1-12">
</div><div id="outline-container-sec-1-12-1" class="outline-4">
<h4 id="sec-1-12-1"><span class="section-number-4">1.12.1</span> <span class="todo TODO">TODO</span> Advantages of immutability and purity</h4>
</div>
<div id="outline-container-sec-1-12-2" class="outline-4">
<h4 id="sec-1-12-2"><span class="section-number-4">1.12.2</span> <span class="todo TODO">TODO</span> Haskell parallelism with rpar and rseq</h4>
</div>
<div id="outline-container-sec-1-12-3" class="outline-4">
<h4 id="sec-1-12-3"><span class="section-number-4">1.12.3</span> <span class="todo TODO">TODO</span> Threadscope</h4>
</div>
<div id="outline-container-sec-1-12-4" class="outline-4">
<h4 id="sec-1-12-4"><span class="section-number-4">1.12.4</span> <span class="todo TODO">TODO</span> Strategies</h4>
</div>
<div id="outline-container-sec-1-12-5" class="outline-4">
<h4 id="sec-1-12-5"><span class="section-number-4">1.12.5</span> <span class="todo TODO">TODO</span> Par monad examples</h4>
</div>
<div id="outline-container-sec-1-12-6" class="outline-4">
<h4 id="sec-1-12-6"><span class="section-number-4">1.12.6</span> <span class="todo TODO">TODO</span> Difference between Parallelism and Concurrency</h4>
</div>
<div id="outline-container-sec-1-12-7" class="outline-4">
<h4 id="sec-1-12-7"><span class="section-number-4">1.12.7</span> <span class="todo TODO">TODO</span> forkIO and MVar</h4>
</div>
<div id="outline-container-sec-1-12-8" class="outline-4">
<h4 id="sec-1-12-8"><span class="section-number-4">1.12.8</span> <span class="todo TODO">TODO</span> Transactions: STM, TVar</h4>
</div>
<div id="outline-container-sec-1-12-9" class="outline-4">
<h4 id="sec-1-12-9"><span class="section-number-4">1.12.9</span> <span class="todo TODO">TODO</span> Async</h4>
</div>
</div>
<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13"><span class="section-number-3">1.13</span> <span class="todo TODO">TODO</span> <code>[0/5]</code> Lecture 13: Comonads</h3>
<div class="outline-text-3" id="text-1-13">
</div><div id="outline-container-sec-1-13-1" class="outline-4">
<h4 id="sec-1-13-1"><span class="section-number-4">1.13.1</span> <span class="todo TODO">TODO</span> Comonad type class &amp; motivation (Identity comonad)</h4>
</div>
<div id="outline-container-sec-1-13-2" class="outline-4">
<h4 id="sec-1-13-2"><span class="section-number-4">1.13.2</span> <span class="todo TODO">TODO</span> <code>[0/4]</code> Zippers</h4>
<div class="outline-text-4" id="text-1-13-2">
</div><ol class="org-ol"><li><a id="sec-1-13-2-1" name="sec-1-13-2-1"></a><span class="todo TODO">TODO</span> List zipper<br  /></li>
<li><a id="sec-1-13-2-2" name="sec-1-13-2-2"></a><span class="todo TODO">TODO</span> Zipper via derivative<br  /></li>
<li><a id="sec-1-13-2-3" name="sec-1-13-2-3"></a><span class="todo TODO">TODO</span> Game of Life<br  /></li>
<li><a id="sec-1-13-2-4" name="sec-1-13-2-4"></a><span class="todo TODO">TODO</span> Array Zipper (image processing)<br  /></li></ol>
</div>
<div id="outline-container-sec-1-13-3" class="outline-4">
<h4 id="sec-1-13-3"><span class="section-number-4">1.13.3</span> <span class="todo TODO">TODO</span> <code>[0/4]</code> Comonads</h4>
<div class="outline-text-4" id="text-1-13-3">
</div><ol class="org-ol"><li><a id="sec-1-13-3-1" name="sec-1-13-3-1"></a><span class="todo TODO">TODO</span> Env<br  /></li>
<li><a id="sec-1-13-3-2" name="sec-1-13-3-2"></a><span class="todo TODO">TODO</span> Traced<br  /></li>
<li><a id="sec-1-13-3-3" name="sec-1-13-3-3"></a><span class="todo TODO">TODO</span> Stream (+ NonEmpty)<br  /></li>
<li><a id="sec-1-13-3-4" name="sec-1-13-3-4"></a><span class="todo TODO">TODO</span> Store<br  /></li></ol>
</div>
<div id="outline-container-sec-1-13-4" class="outline-4">
<h4 id="sec-1-13-4"><span class="section-number-4">1.13.4</span> <span class="todo TODO">TODO</span> codo-notation (aka method)</h4>
</div>
<div id="outline-container-sec-1-13-5" class="outline-4">
<h4 id="sec-1-13-5"><span class="section-number-4">1.13.5</span> <span class="todo TODO">TODO</span> Comonad transformers</h4>
</div>
</div>
<div id="outline-container-sec-1-14" class="outline-3">
<h3 id="sec-1-14"><span class="section-number-3">1.14</span> <span class="todo TODO">TODO</span> <code>[3/6]</code> Lecture 14: Enterprise Haskell</h3>
<div class="outline-text-3" id="text-1-14">
</div><div id="outline-container-sec-1-14-1" class="outline-4">
<h4 id="sec-1-14-1"><span class="section-number-4">1.14.1</span> <span class="done DONE">DONE</span> <code>[3/3]</code> Build tools</h4>
<div class="outline-text-4" id="text-1-14-1">
</div>
<ol class="org-ol"><li><a id="sec-1-14-1-1" name="sec-1-14-1-1"></a><span class="done DONE">DONE</span> Cabal<br  /><div class="outline-text-5" id="text-1-14-1-1">
<p>
Дерьмо, которое не стоит использовать как основную систему сборки.
Есть файл <code>.cabal</code>. Это некий <code>Makefile</code> для проектов на хаскеле. Там
содержится мета-информация плюс что и как собирать. Workflow:
</p>
<div class="org-src-container">

<pre class="src src-sh">$ cabal init
$ cabal sandbox init
$ cabal install --only-dependencies
$ cabal build
</pre>
</div>
<p>
Артефакты будут в папке <code>./dist/</code>. В общем <code>Cabal</code> сосет:)
</p>
</div>
</li>
<li><a id="sec-1-14-1-2" name="sec-1-14-1-2"></a><span class="done DONE">DONE</span> Stack<br  /><div class="outline-text-5" id="text-1-14-1-2">
<p>
Классная штука для сборки проектов на хаскеле. Что делает:
</p>
<ol class="org-ol">
<li>Устанавливает <code>GHC</code> автоматически, в отдельное место
</li>
<li>Устанавливает все зависимости для проекта
</li>
<li>Собирает проект
</li>
<li>Тестирует проект
</li>
</ol>

<p>
Workflow:
</p>
<div class="org-src-container">

<pre class="src src-sh">$ stack new my-project
$ cd my-project
$ stack setup
$ stack build my-project
$ stack exec my-project-executable
</pre>
</div>
</div>
</li>
<li><a id="sec-1-14-1-3" name="sec-1-14-1-3"></a><span class="done DONE">DONE</span> Nix<br  /><div class="outline-text-5" id="text-1-14-1-3">
<p>
Короче какая-то тула для сборки тоже. Есть ссылка:
<a href="https://www.reddit.com/r/haskell/comments/5gh2mx/what_is_your_haskell_dev_environmentworkflow/dasiz10/">Stack and Nix comparison</a>
</p>
</div>
</li></ol>
</div>
<div id="outline-container-sec-1-14-2" class="outline-4">
<h4 id="sec-1-14-2"><span class="section-number-4">1.14.2</span> <span class="done DONE">DONE</span> Testing: HSpec, QuickCheck</h4>
<div class="outline-text-4" id="text-1-14-2">
<p>
<code>HSpec</code> - тула для юнит-тестов:
</p>
<div class="org-src-container">

<pre class="src src-haskell">-- file Spec.hs
import Test.Hspec
import Test.QuickCheck
import Control.Exception (evaluate)

main :: IO ()
main = hspec $ do
    describe "Prelude.head" $ do
        it "returns the first element of a list" $ do
            head [23..] `shouldBe` (23 :: Int)

        it "throws an exception if used with an empty list" $ do
            evaluate (head []) `shouldThrow` anyException
</pre>
</div>
<div class="org-src-container">

<pre class="src src-sh">$ runhaskell Spec.hs

Prelude.head
  returns the first element of a list
  throws an exception if used with an empty list

Finished in 0.0055 seconds
2 examples, 0 failures
</pre>
</div>
<p>
<code>QuickCheck</code> - тула для тестирования каких-либо свойств:
</p>
<div class="org-src-container">

<pre class="src src-haskell">getList = find 5 where
    find 0 = return []
    find n = do
        ch &larr; getChar
        if ch `elem` ['a'..'e'] then do
            tl &larr; find (n - 1)
            return (ch : tl)
        else
            find n

-- | A thin monadic skin layer
getList :: IO [Char]
getList = fmap take5 getContents

-- | The actual worker
take5 :: [Char] &rarr; [Char]
take5 = take 5 . filter (`elem` ['a'..'e'])
</pre>
</div>
<p>
Простой пример:
</p>
<div class="org-src-container">

<pre class="src src-haskell">import Data.Char
import Test.QuickCheck

{-
ghci&gt; quickCheck ((\s &rarr; s == s) :: [Char] &rarr; Bool)
+++ OK, passed 100 tests.

ghci&gt; quickCheck ((\s &rarr; (reverse.reverse) s == s) :: [Char] &rarr; Bool)
+++ OK, passed 100 tests.
-}
</pre>
</div>
<p>
Собственно протестируем некоторые свойства:
</p>
<div class="org-src-container">

<pre class="src src-haskell">-- | &forall; s . length (take5 s) &equiv; 5
{-
ghci&gt; quickCheck (\s &rarr; length (take5 s) == 5)
"*** Failed! Falsifiable (after 1 test):"
""
-}

-- | &forall; s . length (take5 s) &le; 5
{-
ghci&gt; quickCheck (\s &rarr; length (take5 s) &lt;= 5)
+++ OK, passed 100 tests.
-}

-- | &forall; s . &forall; e . e &isin; take5 s &rArr; e &isin; ['abcde']
{-
ghci&gt; quickCheck (\s &rarr; all (`elem` ['a'..'e']) (take5 s))
+++ OK, passed 100 tests.
-}

{-
ghci&gt; quickCheck (\s &rarr; length (take5 s) &lt; 5)
+++ Ok, passed 100 tests.
-}

deepCheck p = check (defaultConfig { configMaxTest = 10000 }) p

{-
ghci&gt; deepCheck (\s &rarr; length (take5 s) &lt; 5)
"*** Failed! Falsifiable (after 186 tests and 16 shrinks):"
"aaaaa"
-}

{-
ghci&gt; verboseCheck ((\s &rarr; length s &lt; 3) :: [Integer] &rarr; Bool)
Passed:
[]
Failed:
[1,3,-4]
"*** Failed!"
Passed:
[3,-4]
...
Falsifiable (after 5 tests and 4 shrinks):
[0,0,0]
-}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-3" class="outline-4">
<h4 id="sec-1-14-3"><span class="section-number-4">1.14.3</span> <span class="done DONE">DONE</span> FFI</h4>
<div class="outline-text-4" id="text-1-14-3">
<p>
Расшифровывается Foreign Function Interface. Пример:
</p>
<div class="org-src-container">

<pre class="src src-C">/* clang -c simple.c -o simple.o */

int example(int a, int b)
{
  return a + b;
}
</pre>
</div>
<div class="org-src-container">

<pre class="src src-haskell">-- ghc simple.o simple_ffi.hs -o simple_ffi

{-# LANGUAGE ForeignFunctionInterface #-}

import Foreign.C.Types

foreign import ccall safe "example"
    example :: CInt &rarr; CInt &rarr; Cint

main = print (example 42 27)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-14-4" class="outline-4">
<h4 id="sec-1-14-4"><span class="section-number-4">1.14.4</span> <span class="todo TODO">TODO</span> <code>[0/2]</code> Databases</h4>
<div class="outline-text-4" id="text-1-14-4">
</div><ol class="org-ol"><li><a id="sec-1-14-4-1" name="sec-1-14-4-1"></a><span class="todo TODO">TODO</span> SQL<br  /></li>
<li><a id="sec-1-14-4-2" name="sec-1-14-4-2"></a><span class="todo TODO">TODO</span> acid-state<br  /></li></ol>
</div>
<div id="outline-container-sec-1-14-5" class="outline-4">
<h4 id="sec-1-14-5"><span class="section-number-4">1.14.5</span> <span class="todo TODO">TODO</span> Network.HTTP</h4>
</div>
<div id="outline-container-sec-1-14-6" class="outline-4">
<h4 id="sec-1-14-6"><span class="section-number-4">1.14.6</span> <span class="todo TODO">TODO</span> Web.Scotty</h4>
</div>
</div>
<div id="outline-container-sec-1-15" class="outline-3">
<h3 id="sec-1-15"><span class="section-number-3">1.15</span> <span class="todo TODO">TODO</span> <code>[0/7]</code> Lecture 15: Advanced type features</h3>
<div class="outline-text-3" id="text-1-15">
</div><div id="outline-container-sec-1-15-1" class="outline-4">
<h4 id="sec-1-15-1"><span class="section-number-4">1.15.1</span> <span class="todo TODO">TODO</span> <code>[0/4]</code> forall keyword</h4>
<div class="outline-text-4" id="text-1-15-1">
</div><ol class="org-ol"><li><a id="sec-1-15-1-1" name="sec-1-15-1-1"></a><span class="todo TODO">TODO</span> -XExplicitForall<br  /></li>
<li><a id="sec-1-15-1-2" name="sec-1-15-1-2"></a><span class="todo TODO">TODO</span> -XExistensialQuantification<br  /></li>
<li><a id="sec-1-15-1-3" name="sec-1-15-1-3"></a><span class="todo TODO">TODO</span> -XRank2Types<br  /></li>
<li><a id="sec-1-15-1-4" name="sec-1-15-1-4"></a><span class="todo TODO">TODO</span> -XRankNTypes<br  /></li></ol>
</div>
<div id="outline-container-sec-1-15-2" class="outline-4">
<h4 id="sec-1-15-2"><span class="section-number-4">1.15.2</span> <span class="todo TODO">TODO</span> <code>[0/4]</code> Examples for all</h4>
<div class="outline-text-4" id="text-1-15-2">
</div><ol class="org-ol"><li><a id="sec-1-15-2-1" name="sec-1-15-2-1"></a><span class="todo TODO">TODO</span> ShowBox<br  /></li>
<li><a id="sec-1-15-2-2" name="sec-1-15-2-2"></a><span class="todo TODO">TODO</span> ST<br  /></li>
<li><a id="sec-1-15-2-3" name="sec-1-15-2-3"></a><span class="todo TODO">TODO</span> Type constraints<br  /></li>
<li><a id="sec-1-15-2-4" name="sec-1-15-2-4"></a><span class="todo TODO">TODO</span> Pattern matching on types<br  /></li></ol>
</div>
<div id="outline-container-sec-1-15-3" class="outline-4">
<h4 id="sec-1-15-3"><span class="section-number-4">1.15.3</span> <span class="todo TODO">TODO</span> <code>[0/2]</code> GADTs</h4>
<div class="outline-text-4" id="text-1-15-3">
</div><ol class="org-ol"><li><a id="sec-1-15-3-1" name="sec-1-15-3-1"></a><span class="todo TODO">TODO</span> Type safe arithmetic expressions<br  /></li>
<li><a id="sec-1-15-3-2" name="sec-1-15-3-2"></a><span class="todo TODO">TODO</span> Parsing to GADT<br  /></li></ol>
</div>
<div id="outline-container-sec-1-15-4" class="outline-4">
<h4 id="sec-1-15-4"><span class="section-number-4">1.15.4</span> <span class="todo TODO">TODO</span> <code>[0/4]</code> -XDataKinds</h4>
<div class="outline-text-4" id="text-1-15-4">
</div><ol class="org-ol"><li><a id="sec-1-15-4-1" name="sec-1-15-4-1"></a><span class="todo TODO">TODO</span> Naturals<br  /></li>
<li><a id="sec-1-15-4-2" name="sec-1-15-4-2"></a><span class="todo TODO">TODO</span> HList<br  /></li>
<li><a id="sec-1-15-4-3" name="sec-1-15-4-3"></a><span class="todo TODO">TODO</span> Type level Symbols<br  /></li>
<li><a id="sec-1-15-4-4" name="sec-1-15-4-4"></a><span class="todo TODO">TODO</span> Vectors with length in type<br  /></li></ol>
</div>
<div id="outline-container-sec-1-15-5" class="outline-4">
<h4 id="sec-1-15-5"><span class="section-number-4">1.15.5</span> <span class="todo TODO">TODO</span> Extensible records</h4>
</div>
<div id="outline-container-sec-1-15-6" class="outline-4">
<h4 id="sec-1-15-6"><span class="section-number-4">1.15.6</span> <span class="todo TODO">TODO</span> -XTypeApplications</h4>
</div>
<div id="outline-container-sec-1-15-7" class="outline-4">
<h4 id="sec-1-15-7"><span class="section-number-4">1.15.7</span> <span class="todo TODO">TODO</span> -XTypeOperators</h4>
</div>
</div>
<div id="outline-container-sec-1-16" class="outline-3">
<h3 id="sec-1-16"><span class="section-number-3">1.16</span> <span class="todo TODO">TODO</span> <code>[0/0]</code> Lecture 16: Idris</h3>
<div class="outline-text-3" id="text-1-16">
<p>
А тем временем <code>Idris</code> идет куда подальше!!!
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Алексей Кацман</p>
<p class="date">Created: 2017-03-27 пн 03:09</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.1.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
